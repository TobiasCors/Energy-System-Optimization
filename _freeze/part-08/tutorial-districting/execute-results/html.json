{
  "hash": "83f2f5513c69a32479be34afa3f2fd83",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial VIII - Police Districting\"\nsubtitle: \"Applied Optimization with Julia\"\n\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\n\nengine: julia\n---\n\n\n\n\n\n\n# Introduction\n\nImagine you're the lead consultant for Hamburg's police force modernization project. The city is facing increasing response times in certain districts, and the Chief of Police has hired you to optimize their district boundaries. Your mission: redesign Hamburg's police districts to ensure rapid response times while meeting several critical operational requirements.\n\nKey Objectives:\n\n- Minimize average response time to incidents\n- Ensure every area has adequate police coverage\n- Enable efficient backup support between districts\n- Account for real-world constraints like traffic patterns\n\nThroughout this tutorial, you'll build this solution step-by-step, starting with a basic model and gradually adding real-world constraints that police departments face daily.\n\n# 1. Modelling the P-Median Problem\n\nYour first task is to fix a prototype model. It contains 6 critical errors that are causing the model to fail. As the lead consultant, you need to:\n\n1. Identify and fix these errors\n2. Document why each fix was necessary in a comment\n3. Validate that your solution makes sense\n\nIn this task it is **not yet necessary** to include contiguity and compactness constraints! If the model takes too long on your machine, you can set the **relative gap to 10% or decrease the time limit**.\n\nTo execute the code, several files are provided, which contain the Euclidean distance between the BAs, the driving time between BAs, the number of incidents per BA, and the hexagonal shapes (a `.shp` file and a `.dbf` file - you need both!). \n\n## Loading Data and Packages\n\nWe start by loading the new `Shapefile` package. **No mistakes here!**\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nimport Pkg\nPkg.add(\"Shapefile\")\n```\n:::\n\n\n\n\n\n\n\n\nWe then load the required packages. If you have not installed them yet, you can do so by modifying the code chunk above to include the missing packages. **Still no mistakes!**\n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nusing JuMP, HiGHS\nusing DelimitedFiles\nusing Shapefile\nusing DataFrames\nusing Plots\n```\n:::\n\n\n\n\n\n\n\n\nWe then define the number of departments, load the data into scope and define the number of departments and the weighted driving times. Make sure to use the correct path to the data files - it should be relative to the location notebook file in a folder called `data`. **Again, no mistakes!**\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\n# Load the data into scope\nfile_directory = \"$(@__DIR__)/data\"\neuclidianDistances = readdlm(\"$file_directory/euclidianDistances0510.csv\",'\\t')\ndrivingTimes = readdlm(\"$file_directory/drivingTimes0510.csv\",'\\t')\nincidentWeights = vec(readdlm(\"$file_directory/incidentWeights0510.csv\",'\\t'))\n\n# Load the Shapefile for plotting\nhexshape = DataFrame(Shapefile.Table(\"$file_directory/grid0510.shp\"))\nsort!(hexshape, :id)\n\n# Define the number of departments\np = 10\n\n# Define the weighted driving times\nweightedDriving = drivingTimes .* transpose(incidentWeights)\n```\n:::\n\n\n\n\n\n\n\n\n## Fixing the Mistakes\n\nFrom here on, the code contains **6 mistakes** you need to correct in order to solve the model. **Mistakes can be anything so be careful!**\n\n\n\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code}\n# MISTAKES BELOW\n\n# Prepare the model instance\npMedianModel = Model(HiGHS.Optimizer)\nset_attribute(pMedianModel, \"presolve\", \"on\")\nset_attribute(model, \"time_limit\", 120.0)\nset_attribute(pMedianModel, \"mip_rel_gap\", 0.0)\n\n# Define the range of the problem instance\nrangeBAs = 1:2\nrangeDepartments = unique(rand(1:size(incidentWeights,1), 100))  # Ensure unique departments (This line is correct!)\n\n# Define variable\n@variable(pMedianModel, X[i = rangeDepartments,j = rangeDepartments], Bin)\n\n# Define objective function\n@objective(pMedianModel, Max, \n    sum(weightedDriving[i,j]* X[i,j] for i in rangeDepartments, j in rangeBAs)\n    )\n\n# Define the constraints\n@constraint(pMedianModel, \n    eachAllocated[j=rangeBAs], \n    sum(X[i,j] for i in rangeDepartments) == 0\n    )\n\n@constraint(pMedianModel,\n    pLocations, \n    sum(X[i,i] for i in rangeDepartments) == p\n    )\n\n@constraint(pMedianModel, \n    departmentNecessary[i=rangeDepartments,j=rangeBAs],\n    2 * X[i,j] <= X[i,i]\n    )\n\n# Start optimization\noptimize!(pMedianModel)\n\n# MISTAKES ABOVE\n```\n:::\n\n\n\n\n\n\n\n\nWe then check the solution. **No mistakes here, as all mistakes are in the code in the cell above!**\n\n\n\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code code-fold=\"true\"}\n# Function to print the model status\nfunction print_model_status(model)\n    begin\n        println()\n    if termination_status(pMedianModel) == OPTIMAL\n        println(\"Great, the solution is optimal.\")\n        println(\"The relative gap is $(relative_gap(pMedianModel))\")\n        println(\"The solve time (in seconds) is $(solve_time(pMedianModel))\")\n    elseif termination_status(pMedianModel) == TIME_LIMIT && has_values(pMedianModel)\n        println(\"Solution is suboptimal due to a time limit, but a primal solution is available\") \n    else\n        error(\"The model was not solved correctly.\") \n    end\n        println(\"The objective value is \", objective_value(pMedianModel)) \n    end\nend\n```\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nprint_model_status (generic function with 1 method)\n```\n:::\n:::\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\nprint_model_status(pMedianModel)\n@assert termination_status(pMedianModel) == OPTIMAL || (termination_status(pMedianModel) == TIME_LIMIT && has_values(pMedianModel)) \"Unfortunate, the model was not solved correctly. Have you corrected all mistakes?\"\nprintln(\"Great, the model was solved correctly.\")\n\n```\n:::\n\n\n\n\n\n\n\n\nThe following code then builds and uses a function to plot the results.\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction visualize_departments(hexshape, X, p)\n    # Convert solution matrix to regular Matrix\n    allAssignments = Matrix(value.(X))\n    \n    # Find assignments where value > 0.5 (accounting for potential floating-point imprecision)\n    assignments = findall(allAssignments .> 0.5)\n    \n    # Create copy of hexshape to avoid modifying original\n    plot_data = copy(hexshape)\n    \n    # Assign departments and initialize colors\n    plot_data.department = rangeDepartments[map(x->x[1], assignments)]\n    plot_data.color = fill(RGB(0/255, 0/255, 0/255), nrow(plot_data))\n    \n    # Get unique department locations and create color mapping\n    department_locations = unique(rangeDepartments[map(x->x[1], assignments)])\n    color_palette = cgrad(:Pastel1_9, p, categorical=true)\n    color_dict = Dict(department_locations[i] => color_palette[i] for i in 1:p)\n    \n    # Color non-department locations\n    for hex in eachrow(plot_data)\n        if hex.id in department_locations\n            hex.color = RGB(0/255, 0/255, 0/255)\n        else\n            hex.color = color_dict[hex.department]\n        end\n    end\n    \n    # Create and return plot\n    return plot(\n        plot_data.geometry,\n        color=plot_data.color',\n        legend=false,\n        axis=false,\n        ticks=false,\n        size=(800,450)\n    )\nend\n\n# Plot the results\nplot_area = visualize_departments(hexshape, X, p)\n```\n:::\n\n\n\n\n\n\n\n\n# 2. Ensuring District Connectivity\n\nThe Police Chief has identified a critical flaw in the initial model: some police units would need to drive through other districts to reach parts of their own district! This creates jurisdictional issues and slower response times.\n\nYour challenge:\n\n- Implement contiguity constraints to ensure each district is fully connected\n- Compare response times before and after adding these constraints\n- Visualize the impact of your changes on the district map\n\n## Conditional Constraints\n\nBefore we start, we will quickly repeat some basic concepts on constraints and conditions in JuMP. You can add conditions to constraints by using the `;` operator. This is useful if you want to add a constraint only under certain conditions. In the example below, the constraint is only active if the Euclidean distance between two BAs is less than 1.5.\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\n@constraint(model, \n    conditionalConstraint[\n        i=rangeDepartments,\n        j=rangeBAs; \n        euclidianDistances[i,j] < 1.5\n        ],\n    X[i,j] == 1\n    )\n```\n:::\n\n\n\n\n\n\n\n\nFurthermore,we can use conditions within constraints by using the `for` keyword. For example, in the constraint below, the sum is only taken over the BAs that are within 1.5 units of BA $i$.\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n@constraint(model, \n    conditionalConstraint2[i=rangeDepartments],\n    sum(X[i,j] for j in rangeBAs if euclidianDistances[i,j] < 1.5) >= 1\n    )\n```\n:::\n\n\n\n\n\n\n\n\n## Extending the Model\n\nNow, we can start to extend the model. Add the contiguity constraint from the lecture to the model.\n\n::: {.callout-important}\nTake a careful look at the Euclidean distances, as you can use them to determine if two BAs are adjacent to each other. If the distance between two BAs is less than 1.5, then the BAs are adjacent to each other. You can use this information to define the new constraint.\n:::\n\n\n\n\n\n\n::: {#20 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\nSolve the model again, this time with the contiguity constraint.\n\n\n\n\n\n\n::: {#22 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\nThe following code prints the model status and visualizes the districts. If your implementation is correct, the districts should be contiguous and the model should have reached optimality or found a feasible solution before hitting the time limit.\n\n\n\n\n\n\n::: {#24 .cell execution_count=0}\n``` {.julia .cell-code}\nprint_model_status(pMedianModel)\ndisplay(visualize_departments(hexshape, X, p))\n```\n:::\n\n\n\n\n\n\n\n\n## Compute the Gap\n\nBased on your results, what is the gap between the solution in the previous task and this task? Write a comment answering the question in cell below. You can also use the cell, to compute the gap based on the objective values.\n\n\n\n\n\n\n::: {#26 .cell execution_count=1}\n``` {.julia .cell-code}\n#=\n\n\n\n=#\n```\n:::\n\n\n\n\n\n\n\n\n::: {.callout-tip}\nIf you computer cannot determine the optimal solution, you can just use the best solutions you found after both runs to compute the gap.\n:::\n\n# 3. Emergency Response Time Guarantees\n\nHamburg's City Council has mandated that high-priority emergencies must receive a response within 20 minutes. Your previous model doesn't guarantee this! Your task: Implement maximum response time constraints.\n\nExtend your model by an additional parameter `max_driving_time = 20` to ensure that no allocation with a driving time $d_{i,j}$ higher than `max_driving_time` minutes from $i$ to $j$ is possible.\n\n\n\n\n\n\n::: {#28 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\n::: {.callout-tip}\nDon't confuse the `weightedDriving` matrix with the `drivingTimes` matrix! The `weightedDriving` matrix contains the weighted driving times, while the `drivingTimes` matrix contains the driving times.\n:::\n\nAgain, solve the model.\n\n\n\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\nThe following code prints the model status and visualizes the districts. If your implementation is correct, the districts with previously longer driving times should have shrinked. Furthermore, the model should have reached optimality or found a feasible solution before hitting the time limit.\n\n\n\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code}\nprint_model_status(pMedianModel)\ndisplay(visualize_departments(hexshape, X, p))\n```\n:::\n\n\n\n\n\n\n\n\n# 4. Planning for Peak Demand\n\nDuring major events or crime waves, districts need backup support from neighboring stations. The Police Union has emphasized this as a critical safety requirement for their officers. Your task: Design constraints ensuring each district has backup support within 20 minutes of the driving time.\n\n\n\n\n\n\n::: {#34 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\n::: {.callout-tip}\nThis is a rather complicated task, so don't worry if you cannot find the correct restriction. Try to come up with something or describe your thoughts in comments if you do not find the correct restriction or a way to implement it. If you are not sure, it often helps to start on paper and to draw the districts and the BAs to find a way to implement it.\n:::\n\nIn case you came up with a solution, solve the model to optimize the layout of the districts.\n\n\n\n\n\n\n::: {#36 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\nIf your implementation is correct, the districts are contiguous and distributed across the city. In addition, the model should have reached optimality or found a feasible solution before hitting the time limit.\n\n\n\n\n\n\n::: {#38 .cell execution_count=0}\n``` {.julia .cell-code}\nprint_model_status(pMedianModel)\ndisplay(visualize_departments(hexshape, X, p))\n```\n:::\n\n\n\n\n\n\n\n\n---\n\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-districting_files"
    ],
    "filters": [],
    "includes": {}
  }
}