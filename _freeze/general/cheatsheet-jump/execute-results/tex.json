{
  "hash": "1427f0d143b647263bcd8b9221388d8e",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"JuMP Syntax Cheatsheet\"\nsubtitle: \"Optimization with Julia\"\n\nhtml:\n    theme: litera\n    highlight-style: breezedark\n    linkcolor: \"#a60000\"\n    code-copy: true\n    code-link: true\n    toc: true\npdf: \n    documentclass: report\n    geometry:\n        - margin=1in\n    fontfamily: roboto\n    fontfamilyoptions: sfdefault\n    colorlinks: true\n\nexecute:\n    eval: false\n---\n\n\n\n\nThis cheatsheet summarizes the most common syntax elements of [JuMP](https://jump.dev/) for optimization modeling in Julia. It includes examples for setting up models, declaring variables and constraints, defining objectives, adjusting solver options, solving, and accessing solutions.\n\n> **Note:** This cheatsheet uses the latest JuMP syntax. For more detailed documentation, visit the [JuMP documentation](https://jump.dev/JuMP.jl/stable/).\n\n# Model Setup\n\n## Importing Packages and Creating a Model\n\n::: {.cell execution_count=1}\n``` {.julia .cell-code}\nusing JuMP, HiGHS\n\n# Create a model with HiGHS optimizer\nmodel = Model(HiGHS.Optimizer)\n\n# Set a time limit for the optimizer (optional)\nset_optimizer_attribute(model, \"time_limit\", 60.0)\n```\n:::\n\n\n# Variables\n\n## Declaration\n\n### Continuous Variables\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\n# Unbounded continuous variable\n@variable(model, x)\n\n# Non-negative continuous variable\n@variable(model, x >= 0)\n\n# Bounded continuous variable (0 <= x <= 10)\n@variable(model, 0 <= x <= 10)\n\n# Fixed variable, x is fixed at 5\n@variable(model, x == 5)\n```\n:::\n\n\n### Integer Variables\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n# Unbounded integer variable\n@variable(model, x, Int)\n\n# Non-negative integer variable\n@variable(model, x >= 0, Int)\n\n# Bounded integer variable (0 <= x <= 10)\n@variable(model, 0 <= x <= 10, Int)\n```\n:::\n\n\n### Binary Variables\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\n# Binary variable (0 or 1)\n@variable(model, x, Bin)\n```\n:::\n\n\n## Containers\n\n### Arrays and Matrices\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n# Array of 5 continuous variables\n@variable(model, x[1:5])\n\n# Non-negative array of variables\n@variable(model, x[1:5] >= 0)\n\n# Binary array of variables\n@variable(model, x[1:5], Bin)\n\n# 3x4 matrix of variables\n@variable(model, x[1:3, 1:4])\n\n# Integer 3x4 matrix\n@variable(model, x[1:3, 1:4], Int)\n```\n:::\n\n\n### Custom Indexing\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\nindices = [\"A\", \"B\", \"C\"]\n@variable(model, x[i in indices])\n```\n:::\n\n\n# Constraints\n\n## Basic Constraints\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# Declare additional variables as needed\n@variable(model, x)\n@variable(model, y)\n\n@constraint(model, con1, 2x + y <= 10)\n@constraint(model, con2, x + 2y >= 5)\n@constraint(model, con3, x == y)   # Equality constraint\n```\n:::\n\n\n## Constraints with Containers\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\n# Array Variables\n@variable(model, x[1:5] >= 0)\n\n# Constraint for each variable element\n@constraint(model, capacity[i=1:5],\n    x[i] <= 100\n)\n\n# Sum constraint across array\n@constraint(model, total_sum,\n    sum(x[i] for i in 1:5) <= 500\n)\n\n# Matrix constraints: each element gets its constraint\n@variable(model, y[1:3, 1:4])\n@constraint(model, matrix_con[i=1:3, j=1:4],\n    y[i,j] <= i + j\n)\n```\n:::\n\n\n## Conditional Constraints\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\n# Constraint applies only for indices where i > 2\n@constraint(model, cond[i=1:5; i > 2], \n    x[i] <= 10\n)\n\n# Multiple conditions for two-dimensional index:\n@constraint(model, cond2[i=1:10, j=1:10; i != j && i + j <= 15],\n    x[i,j] + x[j,i] <= 1\n)\n```\n:::\n\n\n## Constraints with Conditional Summations\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n# Sum over a subset of indices (e.g., i > 2)\n@constraint(model, total_sum,\n    sum(x[i] for i in 1:5 if i > 2) <= 500\n)\n\n# Sum with multiple conditions on a 2D array\n@constraint(model, total_sum2,\n    sum(x[i,j] for i in 1:5, j in 1:5 if i != j && i + j <= 7) <= 1\n)\n```\n:::\n\n\n> **Tip:** Use semicolons (`;`) to separate the index definition from conditions when defining constraints.\n\n# Objective Functions\n\n## Basic Objectives\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n@objective(model, Max, 5x + 3y)   # Maximize\n@objective(model, Min, 2x + 4y)   # Minimize\n```\n:::\n\n\n## Objectives Using Containers\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n# Container-based objective\n@variable(model, z[1:10])\n@objective(model, Min, sum(z[i] for i in 1:10))\n\n# Weighted objective function\nweights = [1, 2, 3, 4, 5]\n@objective(model, Max, \n    sum(weights[i] * z[i] for i in 1:5)\n)\n```\n:::\n\n\n# Solver Options\n\n::: {.cell execution_count=13}\n``` {.julia .cell-code}\n# Recreate model with a solver if needed\nmodel = Model(HiGHS.Optimizer)\n\n# Set a 60-second time limit\nset_time_limit_sec(model, 60)\nprintln(\"Current time limit: \", time_limit_sec(model))\n\n# Tolerance attributes: relative and absolute gap\nset_optimizer_attribute(model, \"mip_rel_gap\", 0.01)  # 1% gap tolerance\nset_optimizer_attribute(model, \"mip_abs_gap\", 0.1)   # Absolute gap tolerance\n\n# Presolve options: enable or disable\nset_optimizer_attribute(model, \"presolve\", \"on\")  # Enable presolve\n# set_optimizer_attribute(model, \"presolve\", \"off\")  # To disable presolve\n```\n:::\n\n\n> **Tip:** Adjust these settings to balance between solution precision and computational speed.\n\n# Solving and Inspecting the Model\n\n::: {.cell execution_count=14}\n``` {.julia .cell-code}\n# Optimize the model\noptimize!(model)\n\n# Check the termination status using MathOptInterface statuses\nstatus = termination_status(model)\nif status == MOI.OPTIMAL\n    println(\"Solution is optimal\")\nelseif status == MOI.TIME_LIMIT && has_values(model)\n    println(\"Time limit reached with a feasible solution\")\nelse\n    println(\"Solver status: \", status)\nend\n\n# Get variable and objective values\nx_val = value(x)\nprintln(\"x value: \", x_val)\n\n# For arrays, retrieve values with broadcasting:\nx_vals = value.(x)\nprintln(\"x array values: \", x_vals)\n\n# Get the objective value\nobj_val = objective_value(model)\nprintln(\"Objective value: \", obj_val)\n```\n:::\n\n\n> **Important:** Always check the termination status before using the solution values.\n\n# Model Modifications\n\n## Variable Updates\n\n::: {.cell execution_count=15}\n``` {.julia .cell-code}\n# Set or update variable bounds\nset_lower_bound(x, 0)\nset_upper_bound(x, 10)\n\n# Fix x to a specific value, then unfix if needed\nfix(x, 5)\nunfix(x)\n```\n:::\n\n\n## Constraint Updates\n\n::: {.cell execution_count=16}\n``` {.julia .cell-code}\n# Delete a constraint if necessary\ndelete(model, con1)\n```\n:::\n\n\n> **Note:** After modifying the model, you will need to re-solve it to update the solution.\n\n---\n\n# Additional Features and Advanced Topics\n\n## Checking Variable Properties\n\n::: {.cell execution_count=17}\n``` {.julia .cell-code}\n# Check bounds for a variable\nprintln(\"Has lower bound? \", has_lower_bound(x))\nprintln(\"Lower bound: \", lower_bound(x))\nprintln(\"Has upper bound? \", has_upper_bound(x))\nprintln(\"Upper bound: \", upper_bound(x))\n\n# Check variable type and retrieve information\nprintln(\"Is x binary? \", is_binary(x))\nprintln(\"Is x integer? \", is_integer(x))\nprintln(\"Variable name: \", name(x))\nprintln(\"Total number of variables: \", num_variables(model))\n```\n:::\n\n\n# Simple Model Example\n\n::: {.cell execution_count=18}\n``` {.julia .cell-code}\n# Create a simple model example\n   using JuMP, HiGHS\n   \n   model = Model(HiGHS.Optimizer)\n   @variable(model, 0 <= x <= 10)\n   @constraint(model, con1, x >= 5)\n   @objective(model, Max, x)\n   \n   optimize!(model)\n   \n   # Introspection on the variable x\n   println(\"Has lower bound? \", has_lower_bound(x))\n   println(\"Lower bound: \", lower_bound(x))\n   println(\"Has upper bound? \", has_upper_bound(x))\n   println(\"Upper bound: \", upper_bound(x))\n   println(\"Is x binary? \", is_binary(x))\n   println(\"Is x integer? \", is_integer(x))\n   println(\"Is x fixed? \", is_fixed(x))\n   println(\"Variable name: \", name(x))\n   println(\"Total number of variables: \", num_variables(model))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning HiGHS 1.9.0 (git hash: 66f735e60): Copyright (c) 2024 HiGHS under MIT licence terms\nCoefficient ranges:\n  Matrix [1e+00, 1e+00]\n  Cost   [1e+00, 1e+00]\n  Bound  [1e+01, 1e+01]\n  RHS    [5e+00, 5e+00]\nPresolving model\n0 rows, 0 cols, 0 nonzeros  0s\n0 rows, 0 cols, 0 nonzeros  0s\nPresolve : Reductions: rows 0(-1); columns 0(-1); elements 0(-1) - Reduced to empty\nSolving the original LP from the solution after postsolve\nModel status        : Optimal\nObjective value     :  1.0000000000e+01\nRelative P-D gap    :  0.0000000000e+00\nHiGHS run time      :          0.00\nHas lower bound? true\nLower bound: 0.0\nHas upper bound? true\nUpper bound: 10.0\nIs x binary? false\nIs x integer? false\nIs x fixed? false\nVariable name: x\nTotal number of variables: 1\n```\n:::\n:::\n\n\n## Key Points\n\n- Always check solution status before using results\n- Set appropriate time limits for large problems\n- Use gap tolerances to balance precision and speed\n- Monitor solve time for performance optimization\n- Consider presolve for complex problems\n\n",
    "supporting": [
      "cheatsheet-jump_files/figure-pdf"
    ],
    "filters": []
  }
}