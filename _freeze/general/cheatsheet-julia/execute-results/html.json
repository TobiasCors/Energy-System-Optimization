{
  "hash": "e07992c7c1407a98005d3abe8f058b93",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Julia Syntax Cheatsheet\"\nsubtitle: \"Optimization with Julia\"\n\nhtml:\n    theme: [default, ../styles.scss]\n    highlight-style: breezedark\n    linkcolor: \"#a60000\"\n    code-copy: true\n    code-link: true\n    toc: true\npdf: \n    documentclass: report\n    geometry:\n        - margin=1in\n    fontfamily: roboto\n    fontfamilyoptions: sfdefault\n    colorlinks: true\n\nexecute:\n    eval: false\n---\n\n\n\n\n\n\n\n\nThis cheatsheet provides a quick reference for Julia programming language syntax and common operations. Julia is a high-level, high-performance programming language designed for numerical and scientific computing. It combines the ease of use of Python or R with the speed of C. For comprehensive documentation, visit:\n\n- [Julia Documentation](https://docs.julialang.org/en/v1/)\n- [Getting Started with Julia](https://docs.julialang.org/en/v1/manual/getting-started/)\n\n# Variables and Basic Types\n\n## Variable Declaration and Types\n\n::: {#2e422548 .cell execution_count=1}\n``` {.julia .cell-code}\n# Basic variable declaration\nx = 1                  # Implicit typing\ny::Int64 = 5          # Explicit type annotation\n\n# Common types\nnum_int = 42          # Integer (Int64)\nnum_float = 19.99     # Float (Float64)\nis_student = true     # Boolean\nname = \"Julia\"        # String\nc = 3 + 4im           # Complex number\nsym = :symbol         # Symbol\n\n# Check type\ntypeof(num_int)       # Returns Int64\ntypeof(num_float)     # Returns Float64\n```\n:::\n\n\n## String Operations\n\n::: {#677cc17d .cell execution_count=2}\n``` {.julia .cell-code}\n# String manipulation\nstr = \"Hello, World!\"\nlength(str)           # String length\nlowercase(str)        # Convert to lowercase\nuppercase(str)        # Convert to uppercase\nstrip(\" text \")       # Remove leading/trailing whitespace\n```\n:::\n\n\n## String Interpolation\n\n::: {#1d8b46b1 .cell execution_count=3}\n``` {.julia .cell-code}\nname = \"Julia\"\nage = 30\n# Basic interpolation\nmsg1 = \"I am $age years old\"\n# Expression interpolation\nmsg2 = \"In 5 years, I'll be $(age + 5)\"\n# Complex interpolation\ngreeting = \"Hello, my name is $name and I am $age years old\"\n```\n:::\n\n\n## Type Conversion\n\n::: {#200a4a8c .cell execution_count=4}\n``` {.julia .cell-code}\n# Convert between types\nfloat_num = Float64(42)    # Int to Float\nint_num = Int64(3.14)      # Float to Int\nstr_num = string(42)       # Number to String\n```\n:::\n\n\n# Key Points\n\n- Variables are dynamic, types are not\n- Use `typeof()` to check variable type\n- String interpolation is powerful for formatted output\n\n# Vectors, Matrices, and Tuples\n\n## Vectors\n\n::: {#f62493d6 .cell execution_count=5}\n``` {.julia .cell-code}\n# Create vectors\ngrades = [95, 87, 91, 78, 88]    # Numeric vector\nnames = [\"Mike\", \"Yola\", \"Elio\"] # String vector\n\n# Vector operations\npush!(grades, 82)       # Add element to end\npop!(grades)           # Remove last element\npopfirst!(grades)      # Remove first element\n\n# Vector indexing\nfirst = grades[1]      # Access first element\nsubset = grades[1:3]   # Access first three elements\n```\n:::\n\n\n## Matrices\n\n::: {#08dfad5c .cell execution_count=6}\n``` {.julia .cell-code}\n# Create matrices\nmatrix = [1 2 3; 4 5 6]    # 2x3 matrix\n# Matrix operations\nmatrix[2,3] = 17           # Change specific element\n\n# Matrix arithmetic\nmatrix1 = [2 2; 3 3]\nmatrix2 = [1 2; 3 4]\nsum_matrix = matrix1 + matrix2      # Matrix addition\nprod_matrix = matrix1 * matrix2     # Matrix multiplication\nelement_prod = matrix1 .* matrix2   # Element-wise multiplication\n\n# Broadcasting\nmatrix .+ 10                # Add 10 to each element\n```\n:::\n\n\n## Tuples\n\n::: {#a58345b1 .cell execution_count=7}\n``` {.julia .cell-code}\n# Create tuples (immutable)\nperson = (\"Elio Smith\", 18, \"Hamburg\")\nrgb = (255, 0, 0)\n\n# Tuple operations\nname = person[1]           # Access first element\nage, city = person[2:3]    # Multiple assignment\n```\n:::\n\n\n## Key Differences\n\n- Vectors: Mutable, 1-dimensional, good for lists\n- Matrices: Mutable, 2-dimensional, good for linear algebra\n- Tuples: Immutable, fixed-size, good for grouping related constants\n\n# Comparison and Logical Operators\n\n## Basic Comparisons\n\n::: {#7706c287 .cell execution_count=8}\n``` {.julia .cell-code}\n# Comparison operators\nx == y    # Equal to\nx != y    # Not equal to\nx < y     # Less than\nx > y     # Greater than\nx <= y    # Less than or equal to\nx >= y    # Greater than or equal to\n\n# Examples\npassword_correct = (input == \"secret123\")\nis_adult = (age >= 18)\ncan_afford = (price <= budget)\n```\n:::\n\n\n## Logical Operators\n\n::: {#af960a8a .cell execution_count=9}\n``` {.julia .cell-code}\n# AND operator (&&)\ncan_buy = (age >= 18) && (money >= price)    # Both conditions must be true\n\n# OR operator (||)\nneed_coat = (temp < 10) || is_raining        # At least one must be true\n\n# NOT operator (!)\nis_closed = !is_open                         # Inverts boolean value\n```\n:::\n\n\n## Chained Comparisons\n\n::: {#d54d05b5 .cell execution_count=10}\n``` {.julia .cell-code}\n# Instead of\nx >= 0 && x <= 10    # Check if x is between 0 and 10\n\n# You can write\n0 <= x <= 10         # More natural syntax\n\n# Real-world examples\nnormal_temp = 36.5 <= body_temp <= 37.5\nwork_hours = 9 <= current_hour < 17\n```\n:::\n\n\n## Key Points\n\n- Comparisons return boolean values (`true` or `false`)\n- `&&` requires all conditions to be true\n- `||` requires at least one condition to be true\n- `!` inverts a boolean value\n- Chained comparisons make range checks more readable\n\n# Loops and Iterations\n\n## For Loops\n\n::: {#24c03bd8 .cell execution_count=11}\n``` {.julia .cell-code}\n# Basic for loop with range\nfor i in 1:3\n    println(i)        # Prints 1, 2, 3\nend\n\n# Iterating over array\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits\n    println(fruit)    # Prints each fruit\nend\n\n# For loop with break\nfor x in 1:10\n    if x == 4\n        break        # Exits loop when x is 4\n    end\nend\n\n# For loop with conditions\nfor x in 1:10\n    if x <= 2\n        println(x)\n    elseif x == 3\n        println(\"Three!\")\n    else \n        break\n    end\nend\n```\n:::\n\n\n## While Loops\n\n::: {#eb7ae6b1 .cell execution_count=12}\n``` {.julia .cell-code}\n# Basic while loop\nnumber = 10\nwhile number >= 5\n    number -= 1      # Decrements until < 5\nend\n\n# Infinite loop with break\ncurrent = 0\nwhile true\n    current += 1\n    if current == 5\n        break        # Exits when condition met\n    end\nend\n\n# While loop with condition\nlives = 3\nwhile lives > 0\n    lives -= 1       # Continues until lives = 0\nend\n```\n:::\n\n\n## Nested Loops\n\n::: {#117c74a9 .cell execution_count=13}\n``` {.julia .cell-code}\n# Nested loop example\nsizes = [\"S\", \"M\", \"L\"]\ncolors = [\"Red\", \"Blue\"]\nfor size in sizes\n    for color in colors\n        println(\"$color $size\")\n    end\nend\n\n# Matrix iteration\nfor i in 1:3\n    for j in 1:2\n        println(\"Position: $i,$j\")\n    end\nend\n```\n:::\n\n\n## List Comprehensions\n\n::: {#e130cacb .cell execution_count=14}\n``` {.julia .cell-code}\n# Basic list comprehension\nsquares = [n^2 for n in 1:5]    # [1,4,9,16,25]\n\n# With condition\nevens = [n for n in 1:10 if n % 2 == 0]    # [2,4,6,8,10]\n\n# Nested comprehension\nmatrix = [i*j for i in 1:3, j in 1:3]    # 3x3 multiplication table\n```\n:::\n\n\n## Key Points\n\n- `for` loops are best when you know the number of iterations\n- `while` loops are useful for unknown iteration counts\n- Use `break` to exit loops early\n- List comprehensions offer concise array creation\n- Nested loops are useful for multi-dimensional iteration\n\n# Dictionaries\n\n## Basic Dictionary Operations\n\n::: {#001d713b .cell execution_count=15}\n``` {.julia .cell-code}\n# Create a dictionary\nstudent_ids = Dict(\n    \"Elio\" => 1001,\n    \"Bob\" => 1002,\n    \"Yola\" => 1003\n)\n\n# Access values\nid = student_ids[\"Elio\"]        # Get value by key\nstudent_ids[\"David\"] = 1004     # Add new key-value pair\ndelete!(student_ids, \"Bob\")     # Remove entry\n\n# Check key existence\nif haskey(student_ids, \"Eve\")\n    println(student_ids[\"Eve\"])\nend\n```\n:::\n\n\n## Advanced Operations\n\n::: {#645a50ca .cell execution_count=16}\n``` {.julia .cell-code}\n# Dictionary with array values\ngrades = Dict(\n    \"Elio\" => [85, 92, 78],\n    \"Bob\" => [76, 88, 94]\n)\n\n# Get all keys and values\nnames = keys(grades)          # Get all keys\nscores = values(grades)       # Get all values\n\n# Iterate over dictionary\nfor (student, grade_list) in grades\n    avg = sum(grade_list) / length(grade_list)\n    println(\"$student: $avg\")\nend\n```\n:::\n\n\n## Common Methods\n\n::: {#6d1d05c7 .cell execution_count=17}\n``` {.julia .cell-code}\n# Dictionary methods\nlength(dict)           # Number of entries\nempty!(dict)           # Remove all entries\nget(dict, key, default)# Get value or default if key missing\nmerge(dict1, dict2)    # Combine two dictionaries\ncopy(dict)             # Create shallow copy\n```\n:::\n\n\n## Key Points\n\n- Keys must be unique\n- Values can be of any type (including arrays)\n- Use `haskey()` to safely check for key existence\n- Dictionaries are mutable (can be changed)\n- Keys are accessed with square brackets `dict[\"key\"]`\n\n# Functions\n\n## Basic Function Definition\n\n::: {#6892705b .cell execution_count=18}\n``` {.julia .cell-code}\n# Basic function with explicit return\nfunction say_hello(name)\n    return \"Hello, $(name)!\"\nend\n\n# Function with implicit return\nfunction multiply(a, b)\n    a * b    # Last expression is automatically returned\nend\n\n# Conditional return\nfunction do_something(a, b)\n    if a > b\n        return a * b\n    else\n        return a + b\n    end\nend\n```\n:::\n\n\n## Advanced Function Features\n\n::: {#0df6537e .cell execution_count=19}\n``` {.julia .cell-code}\n# Optional arguments\nfunction greet(name=\"Guest\", greeting=\"Hello\")\n    \"$greeting, $name!\"\nend\n\n# Multiple return values\nfunction stats(numbers)\n    avg = sum(numbers) / length(numbers)\n    min_val = minimum(numbers)\n    max_val = maximum(numbers)\n    return avg, min_val, max_val\nend\n\n# Anonymous functions\nnumbers = 1:10\nmap(x -> x^2, numbers)  # Square each number\n```\n:::\n\n\n## Function Scope\n\n::: {#3a4eccb9 .cell execution_count=20}\n``` {.julia .cell-code}\n# Local scope example\nfunction bake_cake()\n    secret_ingredient = \"vanilla\"    # Only exists inside function\n    return secret_ingredient        # Must return to access outside\nend\n\n# Variables outside function not accessible inside\nglobal_var = 10\nfunction scope_example()\n    # Can read global_var but can't modify it\n    return global_var + 5\nend\n```\n:::\n\n\n## Multiple Dispatch\n\n::: {#757d4c13 .cell execution_count=21}\n``` {.julia .cell-code}\n# Generic operation for all types\nfunction operation(a, b)\n    \"Generic operation for $(typeof(a)) and $(typeof(b))\"\nend\n\n# Type-specific implementations\noperation(a::Number, b::Number) = a + b        # For numbers\noperation(a::String, b::String) = string(a, b) # For strings\n\n# Usage examples\noperation(10, 20)          # Returns 30\noperation(\"Hello\", \"!\")    # Returns \"Hello!\"\noperation(\"Hi\", 42)        # Uses generic operation\n```\n:::\n\n\n## Key Points\n\n- Functions can have explicit or implicit returns\n- Last expression is automatically returned if no `return` statement\n- Variables inside functions are local by default\n- Multiple dispatch allows different behavior based on argument types\n- Use `return` for early exits or conditional \n\n# Package Management\n\n## Basic Package Operations\n\n::: {#751ece5b .cell execution_count=22}\n``` {.julia .cell-code}\n# Import package manager\nimport Pkg              # Access as Pkg.function()\nusing Pkg              # Import all exported names\n\n# Add packages\nPkg.add(\"DataFrames\")  # Add single package\nPkg.add([\"Package1\", \"Package2\"])  # Add multiple packages\n\n# Update packages\nPkg.update()           # Update all packages\nPkg.update(\"DataFrames\")  # Update specific package\n\n# Remove packages\nPkg.rm(\"DataFrames\")   # Remove package\n```\n:::\n\n\n",
    "supporting": [
      "cheatsheet-julia_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}