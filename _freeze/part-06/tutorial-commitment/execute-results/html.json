{
  "hash": "8cfaa99097f66dff51153a78f8363671",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial VI - Unit Commitment Problem\"\nsubtitle: \"Energy System Optimization with Julia\"\n\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\nengine: julia\n---\n\n\n\n\n\n\n\n\n# 1. Modelling the Unit Commitment Problem\n\nImplement the Unit Commitment problem from the lecture in Julia. Before we start, let's load the necessary packages and data.\n\n\n\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nusing JuMP, HiGHS\nusing CSV\nusing DataFrames\nusing Plots\nusing Dates\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNow, let's load the data. The generator data includes additional parameters for UC, and the scenario data now includes timestamps and hourly values.\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# Get the directory of the current file\nfile_directory = \"$(@__DIR__)/data\"\n\n# Load the data of the thermal generators\ngenerators = CSV.read(\"$file_directory/generator.csv\", DataFrame)\nprintln(\"Number of generators: $(nrow(generators))\")\nprintln(\"First 5 rows of available generators:\")\nprintln(generators[1:5, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of generators: 6\nFirst 5 rows of available generators:\n5×10 DataFrame\n Row │ name     min_power  max_power  variable_cost  fix_cost  min_up_time  mi ⋯\n     │ String3  Int64      Int64      Int64          Int64     Int64        In ⋯\n─────┼──────────────────────────────────────────────────────────────────────────\n   1 │ G1             100        500             50      1000            4     ⋯\n   2 │ G2              50        350             60      1200            2\n   3 │ G3              40        250             55      1300            1\n   4 │ G4              30        200             70      1500            4\n   5 │ G5              30        200             60      1500            4     ⋯\n                                                               4 columns omitted\n```\n:::\n:::\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n# Load the data of the wind turbines\nwindTurbines = CSV.read(\"$file_directory/windTurbine.csv\", DataFrame)\nprintln(\"Number of wind turbines: $(nrow(windTurbines))\")\nprintln(\"Variable cost per wind turbine:\")\nprintln(windTurbines)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of wind turbines: 1\nVariable cost per wind turbine:\n1×2 DataFrame\n Row │ name     variable_cost \n     │ String3  Int64         \n─────┼────────────────────────\n   1 │ T1                  50\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n# Load the scenario data about the demand and wind forecast\nscenarios = CSV.read(\"$file_directory/scenario.csv\", DataFrame)\nprintln(\"First 5 rows of scenarios:\")\nprintln(scenarios[1:5, :])\nprintln(\"Loaded scenarios:\")\nprintln(Vector{String}(unique(scenarios.scenario)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst 5 rows of scenarios:\n5×4 DataFrame\n Row │ scenario  datetime             demand_forecast  wind_forecast \n     │ String3   String31             Int64            Int64         \n─────┼───────────────────────────────────────────────────────────────\n   1 │ S1        2024-01-01 00:00:00              800            200\n   2 │ S1        2024-01-01 01:00:00              750            180\n   3 │ S1        2024-01-01 02:00:00              700            150\n   4 │ S1        2024-01-01 03:00:00              650            120\n   5 │ S1        2024-01-01 04:00:00              600            100\nLoaded scenarios:\n[\"S1\"]\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNext, prepare the data structures for the model. We'll create NamedTuples for generators, wind turbines, and scenarios:\n\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code}\n# This function creates the Named Tuple ThermalGenerator\n# It stores all parameters needed for a thermal generator in the UC problem:\n# - min/max: minimum and maximum power output\n# - fixed_cost: cost per hour when the generator is running\n# - variable_cost: cost per MWh of power produced\n# - min_up_time: minimum number of hours the generator must stay on once started\n# - min_down_time: minimum number of hours the generator must stay off once shut down\n# - ramp_up/down: maximum power change between consecutive hours\n# - startup_cost: one-time cost when starting the generator\nfunction ThermalGenerator(\n    min::Int64,\n    max::Int64,\n    fixed_cost::Int64,\n    variable_cost::Int64,\n    min_up_time::Int64,\n    min_down_time::Int64,\n    ramp_up::Int64,\n    ramp_down::Int64,\n    startup_cost::Int64\n)\n    return (\n        min = min,\n        max = max,\n        fixed_cost = fixed_cost,\n        variable_cost = variable_cost,\n        min_up_time = min_up_time,\n        min_down_time = min_down_time,\n        ramp_up = ramp_up,\n        ramp_down = ramp_down,\n        startup_cost = startup_cost\n    )\nend\n\n# Create dictionaries for the data\n# Each generator's parameters are stored in a NamedTuple for easy access\ndictThermalGenerators = Dict(row.name => ThermalGenerator(\n    row.min_power, row.max_power, row.fix_cost, row.variable_cost,\n    row.min_up_time, row.min_down_time, row.ramp_up, row.ramp_down,\n    row.startup_cost\n) for row in eachrow(generators))\n\n# Create dictionary for wind turbines\n# Wind turbines only have variable costs as they don't have startup/shutdown constraints\ndictWindTurbines = Dict(row.name => (variable_cost = row.variable_cost,) for row in eachrow(windTurbines))\n\n# Create dictionary for scenarios\n# Each scenario contains time series data for demand and wind forecasts\ndate_format = dateformat\"yyyy-mm-dd HH:MM:SS\"\ndictScenarios = Dict()\nfor scenario in unique(scenarios.scenario)\n    scenario_data = scenarios[scenarios.scenario .== scenario, :]\n    dictScenarios[scenario] = (\n        datetime = DateTime.(scenario_data.datetime, date_format),\n        demand_forecast = scenario_data.demand_forecast,\n        wind_forecast = scenario_data.wind_forecast\n    )\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# 2. Implementing Startup Variables and Costs\n\nIn the Unit Commitment problem, we need to track when generators are started up, as this incurs additional costs. This aspect was not covered in detail in the lecture, so let's implement it here.\n\n## Task: Implement Startup Variables and Costs\n\n1. We need to add a binary variable `v_g[g,t]` that equals 1 if generator g is started up at time t, and 0 otherwise.\n2. The startup cost should be included in the objective function.\n3. We need to link the startup variable to the generator status variable `u_g[g,t]`.\n\nThe relationship between `v_g` and `u_g` is:\nIf a generator is off at t-1 (`u_g[g,t-1] = 0`) and on at t (`u_g[g,t] = 1`), then it must have been started up (`v_g[g,t] = 1`).\n\nHow can this be expressed?\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n## YOUR ANSWER HERE\n\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNow, let's implement the Unit Commitment model in a function:\n\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction solve_unit_commitment(dictThermalGenerators::Dict, dictWindTurbines::Dict, scenario)\n    # Create the model\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    \n    # Define the time periods and sets\n    T = 1:length(scenario.datetime)  # Time periods (hours)\n    G = keys(dictThermalGenerators)  # Set of thermal generators\n    W = keys(dictWindTurbines)       # Set of wind turbines\n    \n    # Define variables\n    @variable(model, p_g[g in G, t in T] >= 0)  # Power output of generators [MW]\n    @variable(model, p_w[w in W, t in T] >= 0)  # Power output of wind turbines [MW]\n    @variable(model, u_g[g in G, t in T], Bin)  # Binary variable for generator status (1=on, 0=off)\n    @variable(model, v_g[g in G, t in T], Bin)  # Binary variable for startup (1=startup, 0=no startup)\n    \n    # Objective function: Minimize total costs\n    # Costs include:\n    # 1. Variable costs for power production\n    # 2. Fixed costs when generator is running\n    # 3. Startup costs when generator is started\n    # 4. Variable costs for wind power\n    ## YOUR CODE HERE\n\n    \n    # Power balance constraint: Total generation must equal demand\n    ## YOUR CODE HERE\n\n    \n    # Generator limits: Power output must be within min/max when running\n    ## YOUR CODE HERE\n\n    \n    # Wind limits: Wind power cannot exceed forecast\n    ## YOUR CODE HERE\n\n    \n    # Minimum up time: Generator must stay on for minimum duration after startup\n    ## Tip: Use the startup variable v_g to enforce the minimum up time\n    ## YOUR CODE HERE\n\n    \n    # Minimum down time: Generator must stay off for minimum duration after shutdown\n    ## Tip: Use the startup variable v_g to enforce the minimum down time\n    ## YOUR CODE HERE\n\n    \n    # Ramp rate limits: Power change between consecutive hours is limited\n    ## YOUR CODE HERE\n\n    \n    # Startup variable definition: v_g[g,t] = 1 if generator g is started at time t\n    ## YOUR CODE HERE\n\n    \n    # Solve the model\n    optimize!(model)\n    \n    # Return results\n    return (\n        p_g = value.(p_g),      # Generator power output\n        p_w = value.(p_w),      # Wind power output\n        u_g = value.(u_g),      # Generator status\n        v_g = value.(v_g),      # Startup events\n        total_cost = objective_value(model)\n    )\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Now, let's solve the model for all scenarios and store the results:\n\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n# Create a dataframe to store results\nresults_df = DataFrame(\n    scenario = String[],            # Scenario identifier\n    datetime = DateTime[],          # Timestamp\n    total_cost = Float64[],         # Total system cost\n    wind_curtailment = Float64[],   # Curtailed wind power\n    thermal_generation = Float64[], # Total thermal generation\n    wind_generation = Float64[]     # Total wind generation\n)\n\n# Loop over scenarios\nfor (scenario_name, scenario_data) in dictScenarios\n    solution = solve_unit_commitment(dictThermalGenerators, dictWindTurbines, scenario_data)\n    \n    # Store results for each time period\n    for t in 1:length(scenario_data.datetime)\n        push!(results_df, (\n            scenario_name,\n            scenario_data.datetime[t],\n            solution.total_cost,\n            sum(scenario_data.wind_forecast[t] - solution.p_w[w,t] for w in keys(dictWindTurbines)),\n            sum(solution.p_g[g,t] for g in keys(dictThermalGenerators)),\n            sum(solution.p_w[w,t] for w in keys(dictWindTurbines))\n        ))\n    end\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Finally, let's plot the results:\nWe only have one scenario, so we can plot the results for that scenario like this:\n\n\n\n\n\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code}\n# Plot generation over time\np1 = plot(results_df.datetime, results_df.thermal_generation, \n    label=\"Thermal Generation\", xlabel=\"Time\", ylabel=\"Power [MW]\")\nplot!(results_df.datetime, results_df.wind_generation, \n    label=\"Wind Generation\")\nplot!(results_df.datetime, results_df.wind_curtailment, \n    label=\"Wind Curtailment\")\ntitle!(\"Generation Profile\")\n\n# Plot costs\np2 = plot(results_df.datetime, results_df.total_cost, \n    label=\"Total Cost\", xlabel=\"Time\", ylabel=\"Cost [EUR]\")\ntitle!(\"Cost Profile\")\n\n# Display plots\nplot(p1, p2, layout=(2,1), size=(800,600))\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## Assert the correct objective value\n\n\n\n\n\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code}\n# Assert the correct objective value\nresult_cost = results_df[results_df.scenario .== \"S1\", :total_cost][1]\n@assert isapprox(result_cost, 1.1446e6; atol=1e-2) \"Objective value from results_df is not correct. Check your implementation.\"\nprintln(\"Test passed: The objective value from results_df is correct!\")\n```\n:::\n\n\n\n\n\n\n\n\n\n---\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-commitment_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}