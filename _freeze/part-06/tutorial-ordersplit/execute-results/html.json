{
  "hash": "085e33212bea50fc8589b33af281f303",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial VI - Minimizing Split Orders in E-Commerce\"\nsubtitle: \"Applied Optimization with Julia\"\n\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\n\nengine: julia\n---\n\n\n\n\n\n\n\n\n# Introduction\n\nWe are consulting for FitGear, a rapidly growing e-commerce company specializing in fitness equipment and athletic wear. FitGear is facing a challenge: customer complaints about split orders have increased by 40% in the last quarter. When a customer orders multiple items, they sometimes receive multiple packages from different warehouses, leading to higher shipping costs and frustrated customers.\n\nThis tutorial explores how to optimize SKU allocation across warehouses to minimize split orders using mathematical optimization.\n\n## 1. Coappearance Matrix\n\nFirst, we need to understand which products are frequently purchased together. We'll use a coappearance matrix. It shows how frequently items appear together in customer orders. For each pair of items (i,j), the matrix element Q[i,j] represents the number of orders containing both items i and j. Let's start with a small sample of FitGear's historical order data and determine the coappearance matrix of the transactional data set **manually by hand**.\n\n| $t_{mi}$ | A | B | C | D |\n|----------|---|---|---|---|\n| 1        | 1 | 1 | 1 | 0 |\n| 2        | 1 | 1 | 1 | 0 |\n| 3        | 1 | 1 | 0 | 0 |\n| 4        | 1 | 0 | 0 | 1 |\n| 5        | 1 | 0 | 0 | 1 |\n| 6        | 1 | 0 | 0 | 1 |\n| 7        | 1 | 0 | 0 | 1 |\n| 8        | 0 | 0 | 1 | 1 |\n\nWhat is the resulting **coappearance matrix** from the transactional data set? \nPlease provide it in the following cell as matrix by changing the `0`s to the correct values.\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=1}\n``` {.julia .cell-code}\nQ = [\n    0 0 0 0; \n    0 0 0 0; \n    0 0 0 0; \n    0 0 0 0;\n]\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 2. Maximizing Coappearances\n\nFitGear currently operates two warehouses - one in Hamburg and one in Berlin. Each warehouse has limited storage capacity:\n\n- Hamburg can store 3 different product types (SKUs)\n- Berlin can also store 3 different product types \n\nBased on the coappearance matrix you have determined in the previous assignment, use the model from the lecture to maximise the coappearances **manually by hand**. What is the resulting objective function value of the assignment? Please provide it in the following cell.\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\nobjective_value_by_hand =\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 3. Counting Split Parcels\n\nBased on the output of the optimisation, we don't know the number of split orders yet. Calculate the **number of split orders manually** from your previous solution. \n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\nnumber_of_split_parcels =\n```\n:::\n\n\n\n\n\n\n\n\n\n\n::: {.callout-note}\n## Bonus Question\nIs the solution of the QMKP the optimal solution for the underlying split parcel minimisation problem? Try to come up with another solution that has less split or the same number of split parcels.\n:::\n\n## 4. Implementing the model\n\nAs FitGear continues to grow, the operations team needs a solution that can handle their full product catalog. They now have:\n\n- 12 popular fitness products\n- 40 recent customer orders\n- Two warehouses with different capacities:\n    - Hamburg: 7 SKUs\n    - Berlin: 6 SKUs\n\nThus, we'll now implement a scalable solution using Julia and JuMP that can handle larger datasets.\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\nskus = [\n    \"Running Shoes\",      \n    \"Athletic Socks\",     \n    \"Water Bottle\",       \n    \"Yoga Mat\",          \n    \"Resistance Bands\",  \n    \"Sports Bag\",        \n    \"Protein Powder\",     \n    \"Exercise Shorts\",    \n    \"Training Shirt\",     \n    \"Fitness Tracker\",    \n    \"Foam Roller\",       \n    \"Weight Gloves\"       \n]\n\nwarehouses = [\"Hamburg\", \"Berlin\"]\n\ncapacity = [7, 6]\n\nT = [\n    # First set of transactions (1-20)\n    1 1 0 0 0 0 0 0 0 0 0 0;  # shoes + socks\n    1 1 0 0 0 1 0 0 0 0 0 0;  # shoes + socks + sports bag\n    0 0 0 1 1 0 0 0 0 0 1 0;  # yoga mat + bands + foam roller\n    0 0 1 1 0 0 0 0 0 0 0 0;  # water bottle + yoga mat\n    0 0 0 0 0 0 1 0 0 0 0 0;  # just protein powder\n    0 0 0 0 0 0 1 0 0 0 0 1;  # protein powder + gloves\n    0 0 0 0 0 0 0 1 1 0 0 0;  # shorts + shirt combo\n    0 0 0 0 1 0 0 1 1 0 0 0;  # workout outfit + bands\n    0 0 0 0 0 0 0 0 0 1 0 0;  # just fitness tracker\n    1 1 1 0 0 1 0 1 1 0 0 0;  # full running gear set\n    0 0 0 1 1 0 0 0 0 0 1 1;  # home gym basics\n    0 0 0 0 0 0 1 1 1 0 0 1;  # gym starter pack\n    0 0 1 0 1 0 0 0 0 0 0 0;  # water bottle + bands\n    1 1 0 0 0 0 0 1 1 0 0 0;  # running outfit complete\n    0 0 0 1 1 0 0 0 0 0 1 0;  # yoga equipment set\n    0 0 0 0 0 0 1 0 0 0 0 1;  # protein powder + gloves\n    0 0 1 0 0 0 1 0 0 0 0 0;  # water bottle + protein\n    1 0 0 0 0 1 0 0 0 1 0 0;  # shoes + bag + tracker\n    0 0 0 0 1 0 0 1 1 0 0 0;  # workout outfit + bands\n    0 0 0 1 0 0 0 0 0 0 1 0;  # yoga mat + foam roller\n    1 1 0 0 0 0 0 1 1 0 0 0;  # shoes + socks + workout clothes\n    1 1 0 0 0 1 0 0 0 1 0 0;  # shoes + socks + bag + tracker\n    0 0 0 1 1 0 0 0 0 0 1 1;  # yoga mat + bands + foam roller + gloves\n    0 0 1 1 1 0 0 0 0 0 0 0;  # water bottle + yoga mat + bands\n    0 0 1 0 0 0 1 0 0 0 0 1;  # protein powder + water bottle + gloves\n    0 0 0 0 1 0 1 0 0 0 0 1;  # protein powder + bands + gloves\n    0 0 0 0 0 0 0 1 1 1 0 0;  # shorts + shirt + tracker\n    1 0 0 0 1 0 0 1 1 0 0 0;  # shoes + workout outfit + bands\n    0 0 1 0 0 0 0 0 0 1 0 0;  # water bottle + tracker\n    1 1 1 0 0 1 0 1 1 1 0 0;  # deluxe running gear set\n    0 0 0 1 1 0 1 0 0 0 1 1;  # advanced home gym set\n    0 0 1 0 0 0 1 1 1 0 0 1;  # gym starter pack with water bottle\n    0 0 1 0 1 0 0 0 0 1 0 0;  # water bottle + bands + tracker\n    1 1 0 0 0 1 0 1 1 0 0 0;  # running outfit with bag\n    0 0 0 1 1 0 0 0 0 0 1 1;  # yoga equipment set with gloves\n    0 0 1 0 0 0 1 0 0 0 1 1;  # protein set with foam roller\n    0 0 1 0 0 1 1 0 0 0 0 0;  # water bottle + protein + bag\n    1 0 0 0 0 1 0 0 0 1 1 0;  # shoes + bag + tracker + foam roller\n    0 0 0 0 1 0 0 1 1 1 0 0;  # workout outfit + bands + tracker\n    0 0 0 1 0 0 0 0 0 1 1 0   # yoga mat + tracker + foam roller\n]\n```\n:::\n\n\n\n\n\n\n\n\n\n\nImplement the model in Julia and solve it for the given data set.\n\n::: {.callout-note}\n## Each SKU can only be allocated to one warehouse!\nThe retailer has another requirement: each SKU can only be allocated to one warehouse. Make sure to include this requirement in your model.\n:::\n\n::: {.callout-tip}\n## Use the Juniper solver\nIf you don't have Juniper, Ipopt and/or HiGHS installed, add the solver via Pkg.add(\"Juniper\") and Pkg.add(\"Ipopt\") and Pkg.add(\"HiGHS\"). Juniper is a solver for nonlinear problems, that can be used in combination with Ipopt and HiGHS to solve mixed-integer quadratic problems. If you want to use SCIP, you can also do this by adding JuMP and SCIP and then change the solver in the model definition to `warehouse_model = Model(SCIP.Optimizer())`. Note, that this does not work automatically in Windows, as you will have to install the SCIP binaries manually. On Mac and Linux, it should work out of the box.\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFirst, we start by defining the model.\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n# Definition of the warehouse model\nusing JuMP, Ipopt, HiGHS, Juniper\nipopt = optimizer_with_attributes(Ipopt.Optimizer, \"print_level\" => 0)\nhighs = optimizer_with_attributes(HiGHS.Optimizer, \"output_flag\" => false)\nwarehouse_model = Model(\n    optimizer_with_attributes(\n        Juniper.Optimizer,\n        \"nl_solver\" => ipopt,\n        \"mip_solver\" => highs,\n    ),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPrecompiling JuMP...\n    533.5 ms  ✓ BenchmarkTools\n  25195.4 ms  ✓ MathOptInterface\n   6959.8 ms  ✓ JuMP\n  3 dependencies successfully precompiled in 33 seconds. 53 already precompiled.\nPrecompiling Ipopt...\n   3433.0 ms  ✓ Ipopt\n  1 dependency successfully precompiled in 4 seconds. 71 already precompiled.\nPrecompiling HiGHS...\n   5181.3 ms  ✓ HiGHS\n  1 dependency successfully precompiled in 5 seconds. 56 already precompiled.\nPrecompiling Juniper...\n   1332.3 ms  ✓ Juniper\n  1 dependency successfully precompiled in 1 seconds. 56 already precompiled.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=1}\n```\nA JuMP Model\n├ solver: Juniper\n├ objective_sense: FEASIBILITY_SENSE\n├ num_variables: 0\n├ num_constraints: 0\n└ Names registered in the model: none\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nNext, compute the coappearance matrix based on the transactional data provided in `T`.\n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Assert whether the coappearance matrix is correct.\n@assert Q == Q' \"The coappearance matrix is not symmetric. Have you transposed the transactional data set?\"\n@assert Q[1,1] == 11 \"The coappearance matrix is not correct. Have you multiplied the transposed transactional data set with itself?\"\nprintln(\"Great! The coappearance matrix is correct.\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNow, define the decision variable for the SKU allocation. Please name the variable `X`.\n\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Assert whether the decision variable is correct.\n@assert typeof(X) <: AbstractArray{VariableRef} \"The decision variable X should be an array of JuMP variables\"\n@assert all(is_binary.(X)) \"The decision variable X should be defined as binary\"\n@assert size(X) == (length(skus), length(warehouses)) \"The decision variable X should have dimensions [skus × warehouses]\"\nprintln(\"Great! The decision variable is correctly defined as a binary variable with proper dimensions.\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThen, define the objective function to maximize the coappearance.\n\n\n\n\n\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#24 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Assert whether the objective function is correct.\n@assert typeof(objective_function(warehouse_model)) <: QuadExpr \"The objective function should be a quadratic expression of JuMP variables\"\nprintln(\"Great! The objective function is correctly defined.\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\nTo ensure that each SKU is allocated to one warehouse, add the first constraint.\n\n\n\n\n\n\n\n\n::: {#26 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#28 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Assert whether the single allocation constraint is correct.\n@assert num_constraints(warehouse_model, AffExpr, MOI.EqualTo{Float64}) == length(skus) \"The single allocation constraint should have one constraint for each SKU\"\nprintln(\"Great! The single allocation constraint is correctly defined.\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\nTo ensure that the capacity of each warehouse is not exceeded, add the second constraint.\n\n\n\n\n\n\n\n\n::: {#30 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Assert whether the capacity constraint is correct.\n@assert num_constraints(warehouse_model, AffExpr, MOI.LessThan{Float64}) == length(warehouses) \"The capacity constraint should have one constraint for each warehouse\"\nprintln(\"Great! The capacity constraint is correctly defined.\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\nFinally, solve the model with a solve statement.\n\n\n\n\n\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#36 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Assert whether the model is solved correctly.\n@assert termination_status(warehouse_model) == MOI.OPTIMAL || termination_status(warehouse_model) == MOI.LOCALLY_SOLVED \"The model should either be solved with an optimal solution or with a locally optimal solution\"\n@assert isapprox(objective_value(warehouse_model), 141) \"The objective value should approximaly be 141. Have you correctly implemented the objective function?\"\nprintln(\"Great! The model is correctly solved.\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThe following code prints the objective value, the SKU allocation and the warehouse capacities based on your optimal solution.\n\n\n\n\n\n\n\n\n::: {#38 .cell execution_count=0}\n``` {.julia .cell-code}\nprintln(\"Objective value: \", objective_value(warehouse_model))\nprintln()\nprintln(\"SKU Allocation:\")\nfor i in skus\n    for k in warehouses\n        if value(X[i,k]) > 0.1\n            println(\"SKU: \", i, \" Allocation: \", k)\n        end\n    end\nend\nprintln()\nprintln(\"Warehouse Capacities:\")\nfor k in 1:length(warehouses)\n    println(\"Warehouse: \", warehouses[k], \" Capacity: \", capacity[k], \" Used: \", sum(value.(X[i,warehouses[k]]) for i in skus))\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\nBased on the output of the optimisation, we still don't know the number of split orders. The following code calculates the number of split orders from the SKU allocation for the optimal solution.\n\n\n\n\n\n\n\n\n::: {#40 .cell execution_count=0}\n``` {.julia .cell-code}\n# Binary matrix indicating whether a SKU is allocated to a warehouse.\nX_values = [value(X[i,j]) > 0 ? true : false for i in skus, j in warehouses]\n\n# Function to count the number of split and regular parcels.\nfunction count_split_orders(X_input, transactional_data)\n    # Initialize the counters for split and regular parcels.\n    split_parcels = 0\n    regular_parcels = 0\n\n    # Iterate over each transaction in the transactional data set.\n    for t in 1:size(transactional_data,1)\n\n        # Check if the first warehouse can fulfill the transaction.\n        if all(X_input[:,1] .>= transactional_data[t,:])\n            regular_parcels += 1\n\n        # Check if the second warehouse can fulfill the transaction.\n        elseif all(X_input[:,2] .>= transactional_data[t,:])\n            regular_parcels += 1\n\n        # If neither warehouse can fulfill the transaction, it is a split.\n        else\n            split_parcels += 1\n            regular_parcels += 1\n        end\n    end\n    return split_parcels, regular_parcels\nend\n\n# Count the number of split and regular parcels for the optimal solution.\nsplit_parcels, regular_parcels = count_split_orders(X_values, T)\n\n# Count the number of split and regular parcels for 100 random solutions.\nsplit_parcels_random = []\nregular_parcels_random = []\nfor trial in 1:100\n    X_random = [rand(Bool) for i in 1:length(skus), j in 1:length(warehouses)]\n    split_parcels_random_trial, regular_parcels_random_trial = count_split_orders(X_random, T)\n    push!(split_parcels_random, split_parcels_random_trial)\n    push!(regular_parcels_random, regular_parcels_random_trial)\nend\nsplit_parcels_random = sum(split_parcels_random)/100\nregular_parcels_random = sum(regular_parcels_random)/100\n\n# Print the number of split and regular parcels.\nprintln(\"Number of split orders (optimal): \", split_parcels)\nprintln(\"Number of regular orders (optimal): \", regular_parcels)\nprintln()\n\n# Print the number of split and regular parcels for the random solution.\nprintln(\"Number of split orders (random): \", split_parcels_random)\nprintln(\"Number of regular orders (random): \", regular_parcels_random)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 5. Analyzing the Results\n\nFitGear's operations team needs to understand the business implications of this optimization:\n\n- Which product categories tend to cluster together in the same warehouse? For example, do workout clothes tend to be stored together?\n- How many fewer split shipments would FitGear have compared to their current random allocation?\n- How might this new allocation affect warehouse operations and picking efficiency?\n\nYour answer goes here, thinking from the business perspective. A few sentences are fully sufficient!\n\n\n\n\n\n\n\n\n::: {#42 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR ANSWER BELOW\n#=\n\n\n\n=#\n```\n:::\n\n\n\n\n\n\n\n\n\n---\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-ordersplit_files"
    ],
    "filters": [],
    "includes": {}
  }
}