{
  "hash": "5ef7c93e282900dc50fc3e70b5f55444",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial XI - Multi-Energy System Optimization Framework\"\nsubtitle: \"Energy System Optimization with Julia\"\nauthor: \"Dr. Tobias Cors\"\ninstitute: \"Hamburg University of Applied Science - Summer 2025\"\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\nengine: julia\n---\n\n\n\n\n\n\n\n\n# [General Multi-Energy System Framework]{.flow} {.title}\n\n## Introduction\n\nThis tutorial demonstrates the implementation of a **general multi-energy system optimization framework** in Julia, following the mathematical formulation from the lecture. The framework is designed to be technology-agnostic and flexible, allowing you to model and optimize energy systems with multiple energy carriers (e.g., electricity, hydrogen, heat, methanol, CO₂, etc.) and a wide range of conversion, storage, and supply technologies.\n\nThe model is structured to:\n- Optimize investment and operational decisions across all technologies and carriers\n- Allow easy extension to new technologies and energy carriers by changing sets and parameters\n- Enable robust planning under uncertainty via scenario-based stochastic optimization\n\nIn this tutorial, you will:\n- Build the general sets and parameters for the framework\n- Generate example data for a multi-carrier system\n- Implement the model in Julia using JuMP\n- Extend the system with a methanol synthesis plant and a carbon capture unit\n\n## Mathematical Framework Overview\n\n### Sets\n- $\\mathcal{T}$: Time periods\n- $\\mathcal{E}$: Energy carriers/fuels (e.g., electricity, hydrogen, CO₂, methanol)\n- $\\mathcal{E}^D$: Subset of carriers with demand constraints\n- $\\mathcal{G}$: All technology units\n- $\\mathcal{G}^S$: Storage units\n- $\\mathcal{G}^{Var}$: Variable renewable units (e.g., wind, PV)\n- $\\mathcal{G}^{Conv}$: Conversion units (e.g., electrolyzer, methanol synthesis)\n- $\\mathcal{G}^{Sup}$: Supply units (e.g., grid, CO₂ supply)\n- $\\Omega$: Scenarios\n\n### Variables\n- **Investment**: $P_g^{nom}$ (nominal capacity), $SOC_g^{nom}$ (storage energy capacity)\n- **Operation**: $x_{g,e,t,\\omega}^{in}$ (input flow), $x_{g,e,t,\\omega}^{out}$ (output flow), $x_{g,t,\\omega}^{total}$ (activity), $soc_{g,t,\\omega}$ (state of charge), $f_{e,t,\\omega}^{buy}$, $f_{e,t,\\omega}^{sell}$\n- **Binary**: $u_{g,t,\\omega}$ (on/off), $o_{g,t,\\omega}$ (charge/discharge)\n\n### Parameters\n- **Costs**: Investment, variable, startup\n- **Conversion**: $\\sigma_{g,e}^{in}$, $\\sigma_{g,e}^{out}$, $\\Theta_g$\n- **Limits**: $P_g^{max}$, $P_g^{min}$, $SOC_g^{max}$, etc.\n- **Scenario data**: Demand, prices, capacity factors, etc.\n\n### Objective\nMaximize profit (revenues from selling carriers minus costs for buying, variable costs, startup costs, and investment costs).\n\n### Key Constraints\n- Investment cost and budget\n- Input-output relationships for all technologies\n- Storage dynamics\n- Energy carrier balances for all $e$\n- Technology and storage capacity limits\n- (Optional) Unit commitment and startup costs\n\n::: {.callout-note}\nThis framework is highly flexible: to add a new technology or carrier, simply add its parameters and update the relevant sets. In this tutorial, we will extend the system with a methanol synthesis plant (using H₂ and CO₂ as inputs) and a carbon capture unit (as a CO₂ supply).\n:::\n\n# [Data Generation and Model Implementation]{.flow} {.title}\n\n## 1. Load Packages\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\nusing Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"HiGHS\")\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nPkg.add(\"CairoMakie\")\nPkg.add(\"Dates\")\n\n# Required packages\nusing Random\nusing Statistics\nusing DataFrames\nusing CSV\nusing Dates\nusing JuMP\nusing HiGHS\nusing CairoMakie\n\n# Set up CairoMakie\nset_theme!(theme_light())\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 2. Data Generation\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\n# Set random seed for reproducibility\nRandom.seed!(42)\n\n# Get the directory of the current file\nfile_directory = \"$(@__DIR__)/data\"\n\n# Number of scenarios and time periods\nn_scenarios = 5\nn_hours = 168  # One week\n\n# Generate scenario data\nscenario_data = DataFrame(\n    scenario = String[],\n    datetime = DateTime[],\n    demand_meoh = Float64[],\n    wind_cf = Float64[],\n    pv_cf = Float64[],\n    market_price = Float64[],\n    probability = Float64[]\n)\n\n# Base datetime\nbase_datetime = DateTime(2024, 1, 1)\n\n# Generate data for each scenario\nfor s in 1:n_scenarios\n    # Methanol demand (constant for simplicity)\n    demand_meoh = fill(10.0, n_hours)  # 10 t/h equivalent\n\n    # Wind capacity factors\n    wind_cf = rand(n_hours)\n\n    # PV capacity factors (daily pattern)\n    hour_of_day = mod.(0:n_hours-1, 24)\n    pv_cf = max.(0, sin.(π .* hour_of_day ./ 12)) .+ randn(n_hours) .* 0.1\n    pv_cf = max.(0, min.(1, pv_cf))\n\n    # Market prices\n    base_price = 200 .+ 100 .* sin.(2π .* (0:n_hours-1) ./ 24)\n    market_price = base_price .+ randn(n_hours) .* 100\n    market_price = max.(-500, min.(1000, market_price))\n\n    for h in 1:n_hours\n        push!(scenario_data, (\n            \"S$s\",\n            base_datetime + Hour(h-1),\n            demand_meoh[h],\n            wind_cf[h],\n            pv_cf[h],\n            market_price[h],\n            1/n_scenarios\n        ))\n    end\nend\n\nCSV.write(\"$file_directory/scenario.csv\", scenario_data)\n\n# Grid data (electricity supply)\ngrid_data = DataFrame(\n    name = [\"grid\"],\n    taxes_levies = [50.0]  # EUR/MWh\n)\nCSV.write(\"$file_directory/grid.csv\", grid_data)\n\n# Storage data (battery example)\nstorage_data = DataFrame(\n    name = [\"battery\"],\n    energy_cost = [100000.0],  # EUR/MWh\n    power_cost = [50000.0],    # EUR/MW\n    lifetime = [10],\n    discount_rate = [0.05],\n    charge_efficiency = [0.95],\n    discharge_efficiency = [0.95],\n    self_discharge_rate = [0.001]\n)\nCSV.write(\"$file_directory/storage.csv\", storage_data)\n\n# Wind turbine data\nwind_data = DataFrame(\n    name = [\"wind\"],\n    power_cost = [1000000.0],  # EUR/MW\n    lifetime = [20],\n    discount_rate = [0.05]\n)\nCSV.write(\"$file_directory/windTurbine.csv\", wind_data)\n\n# PV data\npv_data = DataFrame(\n    name = [\"pv\"],\n    power_cost = [500000.0],   # EUR/MW\n    lifetime = [25],\n    discount_rate = [0.05]\n)\nCSV.write(\"$file_directory/pv.csv\", pv_data)\n\n# Electrolyzer data (conversion: electricity -> hydrogen)\nelectrolyzer_data = DataFrame(\n    name = [\"electrolyzer\"],\n    power_cost = [800000.0],   # EUR/MW\n    lifetime = [15],\n    discount_rate = [0.05],\n    var_cost = [5.0],          # EUR/MWh H2\n    # Nominal input/output flows at 1 MW nominal power\n    input_carrier = [\"electricity\"],\n    output_carrier = [\"hydrogen\"],\n    input_flow_nom = [1.0],    # 1 MW electricity in\n    output_flow_nom = [0.0018]    # 0.0018 t/h hydrogen out (ca. 60% efficiency)\n)\nCSV.write(\"$file_directory/electrolyzer.csv\", electrolyzer_data)\n\n# Methanol synthesis data (conversion: hydrogen + CO2 -> methanol)\nmethanol_data = DataFrame(\n    name = [\"meoh_synth\"],\n    power_cost = [1200000.0],  # EUR/t H2\n    lifetime = [20],\n    discount_rate = [0.05],\n    var_cost = [10.0],         # EUR/t H2\n    input_carrier = [\"hydrogen,CO2,electricity\"],\n    output_carrier = [\"methanol,water\"],\n    input_flow_nom = [0.19,1.37,0.03],  # 0.19 t/h H2, 1.37 t/h CO2, 0.03 MW electricity in\n    output_flow_nom = [1.0,0.56]        # 1 t methanol out\n)\nCSV.write(\"$file_directory/methanol.csv\", methanol_data)\n\n# Carbon capture (CO2 supply, fixed outflow)\nco2_supply_data = DataFrame(\n    name = [\"co2_supply\"],\n    supply_carrier = [\"CO2\"],\n    outflow_nom = [20.0],      # 20 t CO2 available (fixed)\n    var_cost = [20.0]          # EUR/t CO2\n)\nCSV.write(\"$file_directory/co2_supply.csv\", co2_supply_data)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 3. Load and Process Data\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\n# Load data\nusing DataFrames, CSV\n\n# Load all technology data\nfile_directory = \"$(@__DIR__)/data\"\ndfStorage = CSV.read(\"$file_directory/storage.csv\", DataFrame)\ndfWind = CSV.read(\"$file_directory/windTurbine.csv\", DataFrame)\ndfPV = CSV.read(\"$file_directory/pv.csv\", DataFrame)\ndfElectrolyzer = CSV.read(\"$file_directory/electrolyzer.csv\", DataFrame)\ndfMethanol = CSV.read(\"$file_directory/methanol.csv\", DataFrame)\ndfCO2Supply = CSV.read(\"$file_directory/co2_supply.csv\", DataFrame)\ndfScenarios = CSV.read(\"$file_directory/scenario.csv\", DataFrame)\ndfGrid = CSV.read(\"$file_directory/grid.csv\", DataFrame)\n\n# --- Build technology dictionaries with PVAF calculation ---\n\n# Storage units (G^S)\ndictGS = Dict()\nfor row in eachrow(dfStorage)\n    pvaf = (1 + row.discount_rate)^row.lifetime / \n           (row.discount_rate * (1 + row.discount_rate)^row.lifetime)\n    dictGS[row.name] = (\n        energy_cost = row.energy_cost,\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate,\n        charge_efficiency = row.charge_efficiency,\n        discharge_efficiency = row.discharge_efficiency,\n        self_discharge_rate = row.self_discharge_rate,\n        pvaf = pvaf\n    )\nend\n\n# Variable renewables (G^Var)\ndictGVar = Dict()\nfor row in eachrow(dfWind)\n    pvaf = (1 + row.discount_rate)^row.lifetime / \n           (row.discount_rate * (1 + row.discount_rate)^row.lifetime)\n    dictGVar[row.name] = (\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate,\n        pvaf = pvaf\n    )\nend\nfor row in eachrow(dfPV)\n    pvaf = (1 + row.discount_rate)^row.lifetime / \n           (row.discount_rate * (1 + row.discount_rate)^row.lifetime)\n    dictGVar[row.name] = (\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate,\n        pvaf = pvaf\n    )\nend\n\n# Conversion units (G^Conv)\ndictGConv = Dict()\n# Electrolyzer\nfor row in eachrow(dfElectrolyzer)\n    pvaf = (1 + row.discount_rate)^row.lifetime / \n           (row.discount_rate * (1 + row.discount_rate)^row.lifetime)\n    # Calculate sigma and theta\n    input_carrier = split(row.input_carrier, \",\")\n    output_carrier = split(row.output_carrier, \",\")\n    input_flow_nom = [parse(Float64, x) for x in split(string(row.input_flow_nom), \",\")]\n    output_flow_nom = [parse(Float64, x) for x in split(string(row.output_flow_nom), \",\")]\n    sigma_in = Dict(input_carrier[i] => input_flow_nom[i]/sum(input_flow_nom) for i in 1:length(input_carrier))\n    sigma_out = Dict(output_carrier[i] => output_flow_nom[i]/sum(output_flow_nom) for i in 1:length(output_carrier))\n    theta = sum(output_flow_nom) / sum(input_flow_nom)\n    dictGConv[row.name] = (\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate,\n        var_cost = row.var_cost,\n        input_carrier = input_carrier,\n        output_carrier = output_carrier,\n        sigma_in = sigma_in,\n        sigma_out = sigma_out,\n        theta = theta,\n        pvaf = pvaf\n    )\nend\n# Methanol synthesis\nfor row in eachrow(dfMethanol)\n    pvaf = (1 + row.discount_rate)^row.lifetime / \n           (row.discount_rate * (1 + row.discount_rate)^row.lifetime)\n    input_carrier = split(row.input_carrier, \",\")\n    output_carrier = split(row.output_carrier, \",\")\n    input_flow_nom = [parse(Float64, x) for x in split(string(row.input_flow_nom), \",\")]\n    output_flow_nom = [parse(Float64, x) for x in split(string(row.output_flow_nom), \",\")]\n    sigma_in = Dict(input_carrier[i] => input_flow_nom[i]/sum(input_flow_nom) for i in 1:length(input_carrier))\n    sigma_out = Dict(output_carrier[i] => output_flow_nom[i]/sum(output_flow_nom) for i in 1:length(output_carrier))\n    theta = sum(output_flow_nom) / sum(input_flow_nom)\n    dictGConv[row.name] = (\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate,\n        var_cost = row.var_cost,\n        input_carrier = input_carrier,\n        output_carrier = output_carrier,\n        sigma_in = sigma_in,\n        sigma_out = sigma_out,\n        theta = theta,\n        pvaf = pvaf\n    )\nend\n\n# Supply units (G^Sup)\ndictGSup = Dict()\nfor row in eachrow(dfCO2Supply)\n    dictGSup[row.name] = (\n        supply_carrier = row.supply_carrier,\n        outflow_nom = row.outflow_nom,\n        var_cost = row.var_cost\n    )\nend\n# Grid as supply (electricity)\nfor row in eachrow(dfGrid)\n    dictGSup[row.name] = (\n        supply_carrier = \"electricity\",\n        taxes_levies = row.taxes_levies\n    )\nend\n\n# --- Build general technology dictionary and sets ---\n# Union of all technology dictionaries\ndictG = merge(dictGS, dictGVar, dictGConv, dictGSup)\n\n# Sets of technology names\nGS = collect(keys(dictGS))\nGVar = collect(keys(dictGVar))\nGConv = collect(keys(dictGConv))\nGSup = collect(keys(dictGSup))\nG = collect(keys(dictG))\n\n# --- Build supply dictionary for CO2 supply ---\ndictSupply = Dict()\nfor row in eachrow(dfCO2Supply)\n    dictSupply[row.supply_carrier] = (\n        outflow_nom = row.outflow_nom,\n        var_cost = row.var_cost\n    )\nend\n\n# --- Prepare scenario data with carrier-specific information ---\ndictScenarios = Dict()\nfor scenario in unique(dfScenarios.scenario)\n    scenario_data = dfScenarios[dfScenarios.scenario .== scenario, :]\n    \n    # Create carrier-specific demand dictionary\n    demand = Dict(\n        \"methanol\" => scenario_data.demand_meoh\n    )\n    \n    # Create technology-specific capacity factors\n    cf = Dict(\n        \"wind\" => scenario_data.wind_cf,\n        \"pv\" => scenario_data.pv_cf\n    )\n    \n    # Create carrier-specific market prices\n    market_price = Dict(\n        \"electricity\" => scenario_data.market_price,\n        \"hydrogen\" => fill(300.0, length(scenario_data.market_price)),  # Fixed H2 price\n        \"methanol\" => fill(70.0, length(scenario_data.market_price)),   # Fixed MeOH price (70 EUR/t)\n        \"CO2\" => fill(50.0, length(scenario_data.market_price))         # Fixed CO2 price\n    )\n    \n    dictScenarios[scenario] = (\n        datetime = scenario_data.datetime,\n        demand = demand,\n        cf = cf,\n        market_price = market_price,\n        probability = scenario_data.probability[1]\n    )\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 4. Model Implementation\n\nNow, let's implement the general Multi-Energy System Framework based on the Stochastic System Design model:\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction solve_mes_framework(dictGS, dictGVar, dictGConv, dictGSup, dictScenarios, dictSupply, max_budget)\n    # Create model\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    \n    # Define sets\n    T = 1:168  # Time periods (hours)\n    GS = collect(keys(dictGS))  # Storage units\n    GVar = collect(keys(dictGVar))  # Variable renewable units\n    GConv = collect(keys(dictGConv))  # Conversion units\n    GSup = collect(keys(dictGSup))  # Supply units\n    G = vcat(GS, GVar, GConv, GSup)  # All technology units\n    Ω = collect(keys(dictScenarios))  # Scenarios\n    \n    # Build set of energy carriers E and mapping sets inside the function\n    E = Set{String}()\n    for g in G\n        if haskey(dictG, g)\n            if haskey(dictG[g], :input_carrier)\n                for e in dictG[g].input_carrier\n                    push!(E, e)\n                end\n            end\n            if haskey(dictG[g], :output_carrier)\n                for e in dictG[g].output_carrier\n                    push!(E, e)\n                end\n            end\n            if haskey(dictG[g], :supply_carrier)\n                push!(E, dictG[g].supply_carrier)\n            end\n        end\n    end\n    E = collect(E)\n    \n    # Mapping sets for inflow and outflow carriers for each g\n    E_g_in = Dict(g => get(dictG[g], :input_carrier, String[])) for g in G\n    E_g_out = Dict(g => get(dictG[g], :output_carrier, String[])) for g in G\n    \n    # Carriers with demand\n    ED = [\"methanol\"]  # Only methanol has demand\n    \n    # Decision Variables\n    # Investment variables (First Stage)\n    @variable(model, P_nom[g in G] >= 0)  # Nominal capacity\n    @variable(model, SOC_nom[g in GS] >= 0)  # Storage energy capacity\n    \n    # Operational variables (Second Stage)\n    @variable(model, x_in[g in G, e in E, t in T, ω in Ω] >= 0)  # Input flow\n    @variable(model, x_out[g in G, e in E, t in T, ω in Ω] >= 0)  # Output flow\n    @variable(model, x_total[g in G, t in T, ω in Ω] >= 0)  # Total activity\n    @variable(model, soc[g in GS, t in T, ω in Ω] >= 0)  # State of charge\n    @variable(model, f_buy[e in E, t in T, ω in Ω] >= 0)  # Buy flow\n    @variable(model, f_sell[e in E, t in T, ω in Ω] >= 0)  # Sell flow\n    \n    # Binary variables\n    @variable(model, u[g in GConv, t in T, ω in Ω], Bin)  # On/off status\n    @variable(model, o[g in GS, t in T, ω in Ω], Bin)  # Charge/discharge\n    \n    # Cost variables\n    @variable(model, AC_inv[g in G] >= 0)  # Annual investment cost\n    @variable(model, c_start[g in GConv, t in T, ω in Ω] >= 0)  # Startup cost\n    \n    # Objective Function: Maximize profit\n    @objective(model, Max,\n        # Revenue from selling energy carriers\n        sum(dictScenarios[ω].probability * \n            sum(dictScenarios[ω].market_price[e][t] * f_sell[e,t,ω] \n                for e in E, t in T) for ω in Ω) * 52.1429 -\n        # Costs of buying energy carriers\n        sum(dictScenarios[ω].probability * \n            sum(dictScenarios[ω].market_price[e][t] * f_buy[e,t,ω] \n                for e in E, t in T) for ω in Ω) * 52.1429 -\n        # Variable operating costs\n        sum(dictScenarios[ω].probability * \n            sum(dictGConv[g].var_cost * x_total[g,t,ω] \n                for g in GConv, t in T) for ω in Ω) * 52.1429 -\n        # Investment costs\n        sum(AC_inv[g] for g in G)\n    )\n    \n    # Investment cost constraints\n    @constraint(model, [g in GS], AC_inv[g] == \n        dictGS[g].power_cost/dictGS[g].pvaf * P_nom[g] + \n        dictGS[g].energy_cost/dictGS[g].pvaf * SOC_nom[g])\n    \n    @constraint(model, [g in vcat(GVar, GConv)], AC_inv[g] == \n        dictG[g].power_cost/dictG[g].pvaf * P_nom[g])\n    \n    # Investment budget constraint\n    @constraint(model, sum(AC_inv[g] for g in G) <= max_budget)\n    \n    # Energy conversion constraints\n    # Input-output relationships for conversion units\n    @constraint(model, [g in GConv, e in dictGConv[g].input_carrier, t in T, ω in Ω],\n        x_in[g,e,t,ω] == dictGConv[g].sigma_in[e] * x_total[g,t,ω])\n    \n    @constraint(model, [g in GConv, e in dictGConv[g].output_carrier, t in T, ω in Ω],\n        x_out[g,e,t,ω] == dictGConv[g].sigma_out[e] * dictGConv[g].theta * x_total[g,t,ω])\n    \n    # Technology capacity limits\n    @constraint(model, [g in GConv, t in T, ω in Ω],\n        0.1 * P_nom[g] * u[g,t,ω] <= x_total[g,t,ω] <= P_nom[g] * u[g,t,ω])\n    \n    # Variable energy technologies\n    @constraint(model, [g in GVar, t in T, ω in Ω],\n        x_total[g,t,ω] <= dictScenarios[ω].cf[g][t] * P_nom[g])\n    \n    # Storage constraints\n    @constraint(model, [g in GS, t in 2:length(T), ω in Ω],\n        soc[g,t,ω] == (1 - dictGS[g].self_discharge_rate) * soc[g,t-1,ω] +\n        dictGS[g].charge_efficiency * x_total[g,t,ω] -\n        sum(x_out[g,e,t,ω] for e in E) / dictGS[g].discharge_efficiency)\n    \n    @constraint(model, [g in GS, ω in Ω],\n        soc[g,1,ω] == dictGS[g].charge_efficiency * x_total[g,1,ω] -\n        sum(x_out[g,e,1,ω] for e in E) / dictGS[g].discharge_efficiency)\n    \n    # Storage capacity limits\n    @constraint(model, [g in GS, t in T, ω in Ω],\n        soc[g,t,ω] <= SOC_nom[g])\n    \n    # Storage charging/discharging mutual exclusion\n    @constraint(model, [g in GS, t in T, ω in Ω],\n        0.1 * P_nom[g] * o[g,t,ω] <= x_total[g,t,ω] <= P_nom[g] * o[g,t,ω])\n    \n    @constraint(model, [g in GS, t in T, ω in Ω],\n        0.1 * P_nom[g] * (1-o[g,t,ω]) <= \n        sum(x_out[g,e,t,ω] for e in E) <= P_nom[g] * (1-o[g,t,ω]))\n    \n    # Supply unit constraints (fixed outflow)\n    @constraint(model, [g in GSup, t in T, ω in Ω],\n        haskey(dictGSup[g], :outflow_nom) ? \n        x_out[g,dictGSup[g].supply_carrier,t,ω] <= dictGSup[g].outflow_nom : \n        x_out[g,dictGSup[g].supply_carrier,t,ω] >= 0)\n    \n    # Energy balance constraints\n    @constraint(model, [e in ED, t in T, ω in Ω],\n        sum(x_out[g,e,t,ω] for g in G) + f_buy[e,t,ω] == \n        sum(x_in[g,e,t,ω] for g in G) + f_sell[e,t,ω] + dictScenarios[ω].demand[e][t])\n    \n    # Solve the model\n    optimize!(model)\n    \n    # Check solution status\n    if termination_status(model) != MOI.OPTIMAL\n        ts = termination_status(model)\n        @info \"Optimization finished. The model was not solved correctly. Termination Status: $ts\"\n    end\n    \n    # Return results\n    return (\n        P_nom = value.(P_nom),\n        SOC_nom = value.(SOC_nom),\n        total_cost = objective_value(model),\n        investment_costs = Dict(g => value.(AC_inv[g]) for g in G),\n        operational_variables = Dict(\n            \"x_in\" => value.(x_in),\n            \"x_out\" => value.(x_out),\n            \"x_total\" => value.(x_total),\n            \"soc\" => value.(soc),\n            \"f_buy\" => value.(f_buy),\n            \"f_sell\" => value.(f_sell)\n        )\n    )\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 5. Solve and Analyze Results\n\nLet's solve the model with a maximum budget of 50 million EUR:\n\n\n\n\n\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code}\n# Solve model\nmax_budget = 50_000_000  # 50 million EUR\nresults = solve_mes_framework(dictGS, dictGVar, dictGConv, dictGSup, dictScenarios, dictSupply, max_budget)\n\n# Create results DataFrame\nresults_df = DataFrame(\n    component = String[],\n    capacity = Float64[],\n    investment_cost = Float64[]\n)\n\n# Add results for all technology types\nfor g in keys(results.P_nom)\n    if g in GS\n        push!(results_df, (g, results.P_nom[g], results.investment_costs[g]))\n    elseif g in GVar\n        push!(results_df, (g, results.P_nom[g], results.investment_costs[g]))\n    elseif g in GConv\n        push!(results_df, (g, results.P_nom[g], results.investment_costs[g]))\n    end\nend\n\n# Calculate total costs\ntotal_investment_cost = sum(values(results.investment_costs))\ntotal_cost = results.total_cost\n\n# Print results\nprintln(\"Optimal Multi-Energy System Design:\")\nprintln(\"=\" * 50)\n\n# Storage results\nfor g in GS\n    println(\"$g:\")\n    println(\"  Power Capacity: $(round(results.P_nom[g], digits=2)) MW\")\n    println(\"  Energy Capacity: $(round(results.SOC_nom[g], digits=2)) MWh\")\n    println(\"  Investment Cost: $(round(results.investment_costs[g], digits=2)) EUR/year\")\nend\n\n# Variable renewable results\nfor g in GVar\n    println(\"$g:\")\n    println(\"  Power Capacity: $(round(results.P_nom[g], digits=2)) MW\")\n    println(\"  Investment Cost: $(round(results.investment_costs[g], digits=2)) EUR/year\")\nend\n\n# Conversion unit results\nfor g in GConv\n    println(\"$g:\")\n    println(\"  Power Capacity: $(round(results.P_nom[g], digits=2)) MW\")\n    println(\"  Investment Cost: $(round(results.investment_costs[g], digits=2)) EUR/year\")\nend\n\nprintln(\"\\nCost Summary:\")\nprintln(\"Total Annual Cost: $(round(total_cost, digits=2)) EUR/year\")\nprintln(\"Total Investment Cost: $(round(total_investment_cost, digits=2)) EUR/year\")\n\n# Create operational results DataFrame\noperational_df = DataFrame(\n    scenario = String[],\n    hour = Int[],\n    carrier = String[],\n    demand = Float64[],\n    production = Float64[],\n    storage_energy = Float64[],\n    buy_flow = Float64[],\n    sell_flow = Float64[]\n)\n\n# Add operational data for each scenario and carrier\nfor ω in keys(dictScenarios)\n    for t in 1:168\n        for e in [\"methanol\"]\n            # Calculate total production for this carrier\n            production = sum(results.operational_variables[\"x_out\"][g,e,t,ω] for g in G)\n            \n            # Get storage energy (only for electricity storage)\n            storage_energy = 0.0\n            if e == \"electricity\"\n                for g in GS\n                    storage_energy += results.operational_variables[\"soc\"][g,t,ω]\n                end\n            end\n            \n            push!(operational_df, (\n                ω,\n                t,\n                e,\n                dictScenarios[ω].demand[e][t],\n                production,\n                storage_energy,\n                results.operational_variables[\"f_buy\"][e,t,ω],\n                results.operational_variables[\"f_sell\"][e,t,ω]\n            ))\n        end\n    end\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 6. Create Figures\n\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code}\n# Create figure for component sizes and costs\nfig1 = Figure(size=(1200, 800))\n\n# Component sizes\nax1 = Axis(fig1[1, 1], title=\"Optimal Component Sizes\")\nx_pos = 1:length(results_df.component)\nbarplot!(ax1, x_pos, results_df.capacity)\nax1.xticks = (x_pos, results_df.component)\nax1.xticklabelrotation = π/4\nax1.ylabel = \"Capacity [MWh/MW]\"\n\n# Cost breakdown\nax2 = Axis(fig1[1, 2], title=\"Annual Investment Cost Breakdown\", aspect=1)\nhidespines!(ax2)\nhidedecorations!(ax2)\ncosts = [results.investment_costs[g] for g in results_df.component]\ncolors = [:blue, :green, :orange, :red, :purple, :brown]\nlabels = results_df.component\n\n# Create pie chart\npie!(ax2, costs, color=colors, radius=0.8)\n\n# Create legend\nLegend(fig1[2, 2], [PolyElement(color=c) for c in colors], labels, \"Components\", \n    orientation=:horizontal)\n\n# Display figure\ndisplay(fig1)\n\n# Create operational plots for multi-carrier system\nfig2 = Figure(size=(1400, 1800))\n\n# Methanol system\nax1 = Axis(fig2[1, 1], title=\"Methanol Production and Demand\")\nfor ω in keys(dictScenarios)\n    # Total methanol production\n    total_prod = [sum(results.operational_variables[\"x_out\"][g,\"methanol\",t,ω] for g in G) for t in 1:168]\n    lines!(ax1, 1:168, total_prod, label=\"Production - $ω\")\n    lines!(ax1, 1:168, dictScenarios[ω].demand[\"methanol\"], label=\"Demand - $ω\", linestyle=:dash)\nend\nax1.xlabel = \"Hour\"\nax1.ylabel = \"Production [t/h]\"\naxislegend(ax1)\n\n# Storage operation\nax2 = Axis(fig2[1, 2], title=\"Storage Energy Level\")\nfor g in GS\n    for ω in keys(dictScenarios)\n        lines!(ax2, 1:168, [results.operational_variables[\"soc\"][g,t,ω] for t in 1:168], \n               label=\"$g - $ω\")\n    end\nend\nax2.xlabel = \"Hour\"\nax2.ylabel = \"Energy [MWh]\"\naxislegend(ax2)\n\n# Hydrogen flows\nax3 = Axis(fig2[2, 1], title=\"Hydrogen Production and Consumption\")\nfor ω in keys(dictScenarios)\n    # Hydrogen production (from electrolyzer)\n    h2_prod = [sum(results.operational_variables[\"x_out\"][g,\"hydrogen\",t,ω] for g in G) for t in 1:168]\n    # Hydrogen consumption (by methanol synthesis)\n    h2_cons = [sum(results.operational_variables[\"x_in\"][g,\"hydrogen\",t,ω] for g in G) for t in 1:168]\n    lines!(ax3, 1:168, h2_prod, label=\"Production - $ω\")\n    lines!(ax3, 1:168, h2_cons, label=\"Consumption - $ω\", linestyle=:dash)\nend\nax3.xlabel = \"Hour\"\nax3.ylabel = \"Flow [t/h]\"\naxislegend(ax3)\n\n# CO2 flows\nax4 = Axis(fig2[2, 2], title=\"CO2 Supply and Consumption\")\nfor ω in keys(dictScenarios)\n    # CO2 supply\n    co2_supply = [sum(results.operational_variables[\"x_out\"][g,\"CO2\",t,ω] for g in GSup) for t in 1:168]\n    # CO2 consumption (by methanol synthesis)\n    co2_cons = [sum(results.operational_variables[\"x_in\"][g,\"CO2\",t,ω] for g in G) for t in 1:168]\n    lines!(ax4, 1:168, co2_supply, label=\"Supply - $ω\")\n    lines!(ax4, 1:168, co2_cons, label=\"Consumption - $ω\", linestyle=:dash)\nend\nax4.xlabel = \"Hour\"\nax4.ylabel = \"Flow [t/h]\"\naxislegend(ax4)\n\n# Technology operation\nax5 = Axis(fig2[3, 1], title=\"Technology Operation Levels\")\nfor g in GConv\n    for ω in keys(dictScenarios)\n        lines!(ax5, 1:168, [results.operational_variables[\"x_total\"][g,t,ω] for t in 1:168], \n               label=\"$g - $ω\")\n    end\nend\nax5.xlabel = \"Hour\"\nax5.ylabel = \"Activity Level [MW]\"\naxislegend(ax5)\n\n# Variable renewable operation\nax6 = Axis(fig2[3, 2], title=\"Variable Renewable Generation\")\nfor g in GVar\n    for ω in keys(dictScenarios)\n        lines!(ax6, 1:168, [results.operational_variables[\"x_total\"][g,t,ω] for t in 1:168], \n               label=\"$g - $ω\")\n    end\nend\nax6.xlabel = \"Hour\"\nax6.ylabel = \"Power [MW]\"\naxislegend(ax6)\n\n# Display figure\ndisplay(fig2)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 7. Methanol Synthesis and Carbon Capture Extension\n\nThe framework has been successfully extended with:\n\n1. **Methanol Synthesis Plant**: Converts hydrogen and CO₂ to methanol\n2. **Carbon Capture Unit**: Provides CO₂ supply to the system\n\nLet's analyze the results of this extension:\n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n# Analyze methanol synthesis results\nprintln(\"Methanol Synthesis Analysis:\")\nprintln(\"=\" * 40)\n\n# Calculate average methanol production\navg_meoh_prod = 0.0\nfor ω in keys(dictScenarios)\n    for t in 1:168\n        avg_meoh_prod += sum(results.operational_variables[\"x_out\"][g,\"methanol\",t,ω] for g in G)\n    end\nend\navg_meoh_prod /= (length(keys(dictScenarios)) * 168)\n\nprintln(\"Average Methanol Production: $(round(avg_meoh_prod, digits=2)) t/h\")\nprintln(\"Methanol Synthesis Capacity: $(round(results.P_nom[\"meoh_synth\"], digits=2)) MW\")\nprintln(\"Investment Cost: $(round(results.investment_costs[\"meoh_synth\"], digits=2)) EUR/year\")\n\n# Analyze hydrogen flows\nprintln(\"\\nHydrogen Flow Analysis:\")\nprintln(\"=\" * 40)\n\n# Calculate average hydrogen production and consumption\navg_h2_prod = 0.0\navg_h2_cons = 0.0\nfor ω in keys(dictScenarios)\n    for t in 1:168\n        avg_h2_prod += sum(results.operational_variables[\"x_out\"][g,\"hydrogen\",t,ω] for g in G)\n        avg_h2_cons += sum(results.operational_variables[\"x_in\"][g,\"hydrogen\",t,ω] for g in G)\n    end\nend\navg_h2_prod /= (length(keys(dictScenarios)) * 168)\navg_h2_cons /= (length(keys(dictScenarios)) * 168)\n\nprintln(\"Average Hydrogen Production: $(round(avg_h2_prod, digits=2)) t/h\")\nprintln(\"Average Hydrogen Consumption: $(round(avg_h2_cons, digits=2)) t/h\")\nprintln(\"Electrolyzer Capacity: $(round(results.P_nom[\"electrolyzer\"], digits=2)) MW\")\n\n# Analyze CO2 flows\nprintln(\"\\nCO2 Flow Analysis:\")\nprintln(\"=\" * 40)\n\navg_co2_supply = 0.0\navg_co2_cons = 0.0\nfor ω in keys(dictScenarios)\n    for t in 1:168\n        avg_co2_supply += sum(results.operational_variables[\"x_out\"][g,\"CO2\",t,ω] for g in GSup)\n        avg_co2_cons += sum(results.operational_variables[\"x_in\"][g,\"CO2\",t,ω] for g in G)\n    end\nend\navg_co2_supply /= (length(keys(dictScenarios)) * 168)\navg_co2_cons /= (length(keys(dictScenarios)) * 168)\n\nprintln(\"Average CO2 Supply: $(round(avg_co2_supply, digits=2)) t/h\")\nprintln(\"Average CO2 Consumption: $(round(avg_co2_cons, digits=2)) t/h\")\nprintln(\"CO2 Supply Capacity: $(round(dictSupply[\"CO2\"].outflow_nom, digits=2)) t/h\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 8. Sensitivity Analysis\n\nLet's analyze how the optimal solution changes with different maximum budgets:\n\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\n# Test different budgets\nbudgets = [25_000_000, 50_000_000, 75_000_000, 100_000_000]\nresults_by_budget = Dict()\n\nfor budget in budgets\n    results_by_budget[budget] = solve_mes_framework(dictGS, dictGVar, dictGConv, dictGSup, dictScenarios, dictSupply, budget)\nend\n\n# Create figure\nfig3 = Figure(size=(1200, 800))\n\n# Sort budgets and get corresponding results\nsorted_budgets = sort(budgets)\nsorted_results = [results_by_budget[b] for b in sorted_budgets]\n\n# Component sizes vs budget\nax1 = Axis(fig3[1, 1], title=\"Component Sizes vs Budget\")\nfor g in G\n    if g in results.P_nom\n        lines!(ax1, sorted_budgets, [r.P_nom[g] for r in sorted_results], label=g)\n    end\nend\nax1.xlabel = \"Maximum Budget [EUR]\"\nax1.ylabel = \"Capacity [MWh or MW]\"\naxislegend(ax1)\n\n# Costs vs budget\nax2 = Axis(fig3[1, 2], title=\"Costs vs Budget\")\nlines!(ax2, sorted_budgets, [r.total_cost for r in sorted_results], label=\"Total Annual Cost\")\n\n# Add investment costs for each technology type\nfor g in G\n    if g in results.investment_costs\n        lines!(ax2, sorted_budgets, [r.investment_costs[g] for r in sorted_results], label=g)\n    end\nend\n\nax2.xlabel = \"Maximum Budget [EUR]\"\nax2.ylabel = \"Annual Cost [EUR/year]\"\naxislegend(ax2)\n\n# Display figure\ndisplay(fig3)\n\n# Print key findings\nprintln(\"\\nKey Findings from Budget Sensitivity Analysis:\")\nprintln(\"1. Impact on Component Sizes:\")\nfor g in G\n    if g in results.P_nom\n        println(\"   - $g capacity changes from $(round(sorted_results[1].P_nom[g], digits=2)) to $(round(sorted_results[end].P_nom[g], digits=2)) MW\")\n    end\nend\n\nprintln(\"\\n2. Impact on Costs:\")\nprintln(\"   - Total cost changes from $(round(sorted_results[1].total_cost, digits=2)) to $(round(sorted_results[end].total_cost, digits=2)) EUR/year\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 9. Conclusion\n\nThis tutorial has successfully demonstrated the implementation of a **general multi-energy system optimization framework** with the following key achievements:\n\n### Framework Implementation\n- **Technology-agnostic design**: The framework can handle any combination of energy carriers and conversion technologies\n- **Flexible data structure**: Uses carrier-specific demand, capacity factors, and market prices\n- **Comprehensive constraints**: Implements all framework constraints including energy conversion, storage dynamics, and energy balances\n\n### System Extension\n- **Methanol synthesis**: Successfully integrated hydrogen and CO₂ conversion to methanol\n- **Carbon capture**: Added CO₂ supply as a new energy carrier\n- **Multi-carrier optimization**: Optimized across electricity, hydrogen, methanol, and CO₂ simultaneously\n\n### Key Benefits\n1. **Scalability**: Easy to add new technologies and carriers by updating data files\n2. **Robustness**: Stochastic formulation handles uncertainty in renewable generation and demand\n3. **Comprehensive**: Considers investment and operational decisions simultaneously\n4. **Flexible**: Framework can be adapted to various energy system applications\n\n### Practical Applications\nThe framework can be applied to:\n- Industrial energy systems\n- Microgrid design\n- Power-to-X facilities\n- Multi-energy hubs\n- Renewable energy integration\n\n::: {.callout-note}\nThe general framework provides a powerful foundation for multi-energy system optimization. By changing only the data files (sets and parameters), the same model can be applied to different energy system configurations, making it a versatile tool for energy system planning and optimization.\n:::\n\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-framework_files"
    ],
    "filters": [],
    "includes": {}
  }
}