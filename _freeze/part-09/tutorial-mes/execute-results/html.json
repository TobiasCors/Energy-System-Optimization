{
  "hash": "31566a61b4bd756058ed6dd0b3c9c510",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial VIII - Stochastic Energy System Design Problem\"\nsubtitle: \"Energy System Optimization with Julia\"\nauthor: \"Dr. Tobias Cors\"\ninstitute: \"Hamburg University of Applied Science - Summer 2025\"\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\nengine: julia\n---\n\n\n\n\n\n\n\n\n# [Stochastic System Design]{.flow} {.title}\n\n## System Design Problem\n\nThe system design problem combines investment planning (sizing) and operational optimization to determine the optimal configuration of an energy system. This integrated approach allows us to:\n\n1. Make optimal investment decisions\n2. Account for operational flexibility\n3. Balance investment and operational costs\n4. Consider system-wide interactions\n\n::: {.callout-note}\nThe system design problem is a two-stage optimization problem:\n\n1. First stage: Investment decisions (sizing)\n2. Second stage: Operational decisions (dispatch)\n:::\n\n### Key Components\n\n#### Investment Planning (Sizing)\n- Component selection\n- Capacity sizing\n- Technology mix\n- Investment costs\n\n#### Operational Optimization (Dispatch)\n- Power generation\n- Storage operation\n- Grid interaction\n- Operational costs\n\n### Mathematical Structure\n\n#### Two-Stage Problem\n1. **First Stage (Here-and-Now)**:\n   - Investment decisions\n   - Component sizing\n   - Fixed costs\n\n2. **Second Stage (Wait-and-See)**:\n   - Operational decisions\n   - Power dispatch\n   - Variable costs\n\n#### Objective Function\n$\\text{Minimize} \\quad \\text{Investment Costs} + \\text{Expected Operational Costs}$\n\n::: {.callout-note}\nThe objective function combines:\n\n1. One-time investment costs (annualized)\n2. Expected operational costs over the system lifetime\n:::\n\n### Solution Approaches\n\n#### Deterministic Approach\n- Single scenario\n- Perfect foresight\n- Simplified uncertainty handling\n\n#### Stochastic Approach\n- Multiple scenarios\n- Probability-weighted costs\n- Robust investment decisions\n\n### Applications\n\n#### Energy System Planning\n- Microgrid design\n- Industrial energy systems\n- Residential energy systems\n\n#### Grid Integration\n- Renewable energy integration\n- Storage deployment\n- Grid capacity planning\n\n#### Market Participation\n- Multi-market optimization\n- Price arbitrage\n- Ancillary services\n\n::: {.callout-note}\nThe system design problem provides a comprehensive framework for:\n\n1. Optimal investment decisions\n2. Efficient system operation\n3. Cost-effective energy supply\n4. Sustainable energy systems\n:::\n\n## Stochastic Formulation\n\nThe stochastic system design problem extends the deterministic model by considering multiple scenarios. This allows us to:\n\n1. Account for uncertainty in renewable generation\n2. Consider different demand patterns\n3. Handle price variations\n4. Make robust investment decisions\n\n## Sets\n\n- $\\mathcal{T}$ - Set of time periods indexed by $t \\in \\{1,2,...,|\\mathcal{T}|\\}$\n- $\\mathcal{S}$ - Set of storage systems indexed by $s \\in \\{1,2,...,|\\mathcal{S}|\\}$\n- $\\mathcal{W}$ - Set of wind parks indexed by $w \\in \\{1,2,...,|\\mathcal{W}|\\}$\n- $\\mathcal{V}$ - Set of PV parks indexed by $v \\in \\{1,2,...,|\\mathcal{V}|\\}$\n- $\\Omega$ - Set of scenarios indexed by $\\omega \\in \\{1,2,...,|\\Omega|\\}$\n\n## Decision Variables\n\n### Investment Variables (First Stage)\n- $e^{nom}_s$ - Nominal energy capacity of storage $s$ [MWh]\n- $p^{ch,nom}_s$ - Nominal charging power of storage $s$ [MW]\n- $p^{dis,nom}_s$ - Nominal discharging power of storage $s$ [MW]\n- $p^{nom}_w$ - Nominal power of wind park $w$ [MW]\n- $p^{nom}_v$ - Nominal power of PV park $v$ [MW]\n\n### Operational Variables (Second Stage)\n- $p_{w,t,\\omega}$ - Power output of wind park $w$ at time $t$ in scenario $\\omega$ [MW]\n- $p_{v,t,\\omega}$ - Power output of PV park $v$ at time $t$ in scenario $\\omega$ [MW]\n- $p^{in}_{t,\\omega}$ - Power inflow through market at time $t$ in scenario $\\omega$ [MW]\n- $p^{out}_{t,\\omega}$ - Power outflow through market at time $t$ in scenario $\\omega$ [MW]\n- $p^{ch}_{s,t,\\omega}$ - Charging power of storage $s$ at time $t$ in scenario $\\omega$ [MW]\n- $p^{dis}_{s,t,\\omega}$ - Discharging power of storage $s$ at time $t$ in scenario $\\omega$ [MW]\n- $e_{s,t,\\omega}$ - Energy level of storage $s$ at time $t$ in scenario $\\omega$ [MWh]\n\n### Annual Cost Variables\n- $AC^{inv}_s$ - Annual investment cost for storage $s$ [EUR/year]\n- $AC^{inv}_w$ - Annual investment cost for wind park $w$ [EUR/year]\n- $AC^{inv}_v$ - Annual investment cost for PV park $v$ [EUR/year]\n- $AC^{grid,imp}_{\\omega}$ - Annual grid electricity import cost in scenario $\\omega$ [EUR/year]\n- $AR^{grid,exp}_{\\omega}$ - Annual grid electricity export revenue in scenario $\\omega$ [EUR/year]\n\n## Parameters\n\n### Investment Costs (First Stage)\n- $C^{E}_s$ - Cost per MWh of energy capacity for storage $s$ [EUR/MWh]\n- $C^{P,ch}_s$ - Cost per MW of charging power capacity for storage $s$ [EUR/MW]\n- $C^{P,dis}_s$ - Cost per MW of discharging power capacity for storage $s$ [EUR/MW]\n- $C^{W}_w$ - Cost per MW of wind park $w$ [EUR/MW]\n- $C^{PV}_v$ - Cost per MW of PV park $v$ [EUR/MW]\n- $F^{PVAF}$ - Present value annuity factor for investment costs\n- $B^{max}$ - Maximum investment budget [EUR]\n\n### Operational Parameters (Second Stage)\n- $\\eta^{ch}_s$ - Charging efficiency of storage $s$\n- $\\eta^{dis}_s$ - Discharging efficiency of storage $s$\n- $sdr_s$ - Self-discharge rate of storage $s$ per time step\n- $DoD_s$ - Depth of discharge limit for storage $s$ [%]\n- $f_{w,t,\\omega}$ - Wind capacity factor at time $t$ in scenario $\\omega$ for wind park $w$\n- $f_{v,t,\\omega}$ - Solar capacity factor at time $t$ in scenario $\\omega$ for PV park $v$\n- $d_{t,\\omega}$ - Electric demand at time $t$ in scenario $\\omega$ [MW]\n- $c^{MP}_{t,\\omega}$ - Grid electricity market price at time $t$ in scenario $\\omega$ [EUR/MWh]\n- $c^{TaL}$ - Grid electricity taxes and levies (including Netzentgelt) [EUR/MWh]\n- $\\pi_{\\omega}$ - Probability of scenario $\\omega$\n\n## Objective Function\n\n$\\text{Minimize} \\quad \\sum_{s \\in \\mathcal{S}} AC^{inv}_s + \\sum_{w \\in \\mathcal{W}} AC^{inv}_w + \\sum_{v \\in \\mathcal{V}} AC^{inv}_v + \\sum_{\\omega \\in \\Omega} \\pi_{\\omega} (AC^{grid,imp}_{\\omega} - AR^{grid,exp}_{\\omega})$\n\n::: {.callout-note}\nThe objective function minimizes:\n1. First-stage costs (deterministic):\n   - Investment costs for all components\n2. Second-stage costs (stochastic):\n   - Expected grid electricity costs/revenues\n   - Weighted by scenario probabilities\n:::\n\n## Annual Cost Constraints\n\n### Investment Costs (First Stage)\n$AC^{inv}_s = \\frac{C^{E}_s}{F^{PVAF}} e^{nom}_s + C^{P,ch}_s p^{ch,nom}_s + C^{P,dis}_s p^{dis,nom}_s \\quad \\forall s \\in \\mathcal{S}$\n$AC^{inv}_w = \\frac{C^{W}_w}{F^{PVAF}} p^{nom}_w \\quad \\forall w \\in \\mathcal{W}$\n$AC^{inv}_v = \\frac{C^{PV}_v}{F^{PVAF}} p^{nom}_v \\quad \\forall v \\in \\mathcal{V}$\n\n### Investment Budget\n$\\sum_{s \\in \\mathcal{S}} (C^{E}_s e^{nom}_s + C^{P,ch}_s p^{ch,nom}_s + C^{P,dis}_s p^{dis,nom}_s) + \\sum_{w \\in \\mathcal{W}} C^{W}_w p^{nom}_w + \\sum_{v \\in \\mathcal{V}} C^{PV}_v p^{nom}_v \\leq B^{max}$\n\n::: {.callout-note}\nThe investment budget constraint ensures that:\n1. Total investment costs do not exceed the maximum budget\n2. Includes all component investments:\n   - Storage systems (energy and power capacity)\n   - Wind parks\n   - PV parks\n3. Applies to first-stage decisions only\n:::\n\n### Grid Electricity Costs (Second Stage)\n$AC^{grid,imp}_{\\omega} = \\sum_{t \\in \\mathcal{T}} (c^{MP}_{t,\\omega} + c^{TaL}) p^{in}_{t,\\omega} \\quad \\forall \\omega \\in \\Omega$\n$AR^{grid,exp}_{\\omega} = \\sum_{t \\in \\mathcal{T}} c^{MP}_{t,\\omega} p^{out}_{t,\\omega} \\quad \\forall \\omega \\in \\Omega$\n\n## Constraints\n\n### Power Balance\n$\\sum_{w \\in \\mathcal{W}} p_{w,t,\\omega} + \\sum_{v \\in \\mathcal{V}} p_{v,t,\\omega} + (p^{in}_{t,\\omega} - p^{out}_{t,\\omega}) + \\sum_{s \\in \\mathcal{S}} (p^{dis}_{s,t,\\omega} - p^{ch}_{s,t,\\omega}) = d_{t,\\omega} \\quad \\forall t \\in \\mathcal{T}, \\omega \\in \\Omega$\n\n### Component Limits\n\n#### Wind Parks\n$0 \\leq p_{w,t,\\omega} \\leq f_{w,t,\\omega} p^{nom}_w \\quad \\forall w \\in \\mathcal{W}, t \\in \\mathcal{T}, \\omega \\in \\Omega$\n\n#### PV Parks\n$0 \\leq p_{v,t,\\omega} \\leq f_{v,t,\\omega} p^{nom}_v \\quad \\forall v \\in \\mathcal{V}, t \\in \\mathcal{T}, \\omega \\in \\Omega$\n\n#### Storage Systems\n$0 \\leq p^{ch}_{s,t,\\omega} \\leq p^{ch,nom}_s \\quad \\forall s \\in \\mathcal{S}, t \\in \\mathcal{T}, \\omega \\in \\Omega$\n$0 \\leq p^{dis}_{s,t,\\omega} \\leq p^{dis,nom}_s \\quad \\forall s \\in \\mathcal{S}, t \\in \\mathcal{T}, \\omega \\in \\Omega$\n$DoD_s e^{nom}_s \\leq e_{s,t,\\omega} \\leq e^{nom}_s \\quad \\forall s \\in \\mathcal{S}, t \\in \\mathcal{T}, \\omega \\in \\Omega$\n\n### Storage Energy Balance\n$e_{s,t,\\omega} = (1-sdr_s)e_{s,t-1,\\omega} + \\eta^{ch}_s p^{ch}_{s,t,\\omega} - \\frac{p^{dis}_{s,t,\\omega}}{\\eta^{dis}_s} \\quad \\forall s \\in \\mathcal{S}, t \\in \\mathcal{T}, \\omega \\in \\Omega$\n\n::: {.callout-note}\nThe stochastic formulation:\n1. First-stage decisions (here-and-now):\n   - Component sizing\n   - Investment costs\n2. Second-stage decisions (wait-and-see):\n   - Operational decisions\n   - Scenario-dependent costs\n3. Key differences from deterministic model:\n   - Time-dependent parameters become scenario-dependent\n   - Operational variables become scenario-dependent\n   - Objective includes expected costs\n:::\n\n\n# [Implementation of the Stochastic System Design Problem]{.flow} {.title}\n\n## 1. Load Packages\n\n\n\n\n\n\n\n\n::: {#2 .cell execution_count=0}\n``` {.julia .cell-code}\nusing Pkg\nPkg.add(\"JuMP\")\nPkg.add(\"HiGHS\")\nPkg.add(\"CSV\")\nPkg.add(\"DataFrames\")\nPkg.add(\"CairoMakie\")\nPkg.add(\"Dates\")\n\n# Required packages\nusing Random\nusing Statistics\nusing DataFrames\nusing CSV\nusing Dates\nusing JuMP\nusing HiGHS\nusing CairoMakie\n\n# Set up CairoMakie\nset_theme!(theme_light())\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 2. Data Generation\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=0}\n``` {.julia .cell-code}\n# Set random seed for reproducibility\nRandom.seed!(42)\n\n# Get the directory of the current file\nfile_directory = \"$(@__DIR__)/data\"\n\n# Number of scenarios and time periods\nn_scenarios = 5\nn_hours = 168  # One week\n\n# Generate scenario data\nscenario_data = DataFrame(\n    scenario = String[],\n    datetime = DateTime[],\n    demand = Float64[],\n    wind_cf = Float64[],\n    pv_cf = Float64[],\n    market_price = Float64[],\n    probability = Float64[]\n)\n\n# Base datetime\nbase_datetime = DateTime(2024, 1, 1)\n\n# Generate data for each scenario\nfor s in 1:n_scenarios\n    # Generate base demand profile (daily pattern)\n    base_demand = 60 .+ 40 .* sin.(2π .* (0:n_hours-1) ./ 24)\n    \n    # Add random variations for each scenario\n    demand = base_demand .+ randn(n_hours) .* 10\n    demand = max.(20, min.(100, demand))  # Clamp between 20 and 100 MW\n    \n    # Generate wind capacity factors\n    wind_cf = rand(n_hours)  # Random between 0 and 1\n    \n    # Generate PV capacity factors (daily pattern)\n    hour_of_day = mod.(0:n_hours-1, 24)\n    pv_cf = max.(0, sin.(π .* hour_of_day ./ 12)) .+ randn(n_hours) .* 0.1\n    pv_cf = max.(0, min.(1, pv_cf))  # Clamp between 0 and 1\n    \n    # Generate market prices\n    base_price = 200 .+ 100 .* sin.(2π .* (0:n_hours-1) ./ 24)\n    market_price = base_price .+ randn(n_hours) .* 100\n    market_price = max.(-500, min.(1000, market_price))  # Clamp between -500 and 1000\n    \n    # Add data to DataFrame\n    for h in 1:n_hours\n        push!(scenario_data, (\n            \"S$s\",\n            base_datetime + Hour(h-1),\n            demand[h],\n            wind_cf[h],\n            pv_cf[h],\n            market_price[h],\n            1/n_scenarios  # Equal probability for each scenario\n        ))\n    end\nend\n\n# Save scenario data\nCSV.write(\"$file_directory/scenario.csv\", scenario_data)\n\n# Create grid data\ngrid_data = DataFrame(\n    name = [\"grid\"],\n    taxes_levies = [50.0]  # 50 EUR/MWh for taxes and levies\n)\n\n# Save grid data\nCSV.write(\"$file_directory/grid.csv\", grid_data)\n\n# Create storage data\nstorage_data = DataFrame(\n    name = [\"storage\"],\n    energy_cost = [100000.0],  # 100,000 EUR/MWh\n    power_cost = [50000.0],    # 50,000 EUR/MW\n    lifetime = [10],           # 10 years\n    discount_rate = [0.05],    # 5% discount rate\n    charge_efficiency = [0.95],\n    discharge_efficiency = [0.95],\n    self_discharge_rate = [0.001]  # 0.1% per hour\n)\n\n# Save storage data\nCSV.write(\"$file_directory/storage.csv\", storage_data)\n\n# Create wind turbine data\nwind_data = DataFrame(\n    name = [\"wind\"],\n    power_cost = [1000000.0],  # 1,000,000 EUR/MW\n    lifetime = [20],           # 20 years\n    discount_rate = [0.05]     # 5% discount rate\n)\n\n# Save wind data\nCSV.write(\"$file_directory/windTurbine.csv\", wind_data)\n\n# Create PV data\npv_data = DataFrame(\n    name = [\"pv\"],\n    power_cost = [500000.0],   # 500,000 EUR/MW\n    lifetime = [25],           # 25 years\n    discount_rate = [0.05]     # 5% discount rate\n)\n\n# Save PV data\nCSV.write(\"$file_directory/pv.csv\", pv_data)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 3. Load and Process Data\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=0}\n``` {.julia .cell-code}\n# Load and process data into dictionaries\ndfStorage = CSV.read(\"$file_directory/storage.csv\", DataFrame)\ndfWindTurbines = CSV.read(\"$file_directory/windTurbine.csv\", DataFrame)\ndfPV = CSV.read(\"$file_directory/pv.csv\", DataFrame)\ndfScenarios = CSV.read(\"$file_directory/scenario.csv\", DataFrame)\ndfGrid = CSV.read(\"$file_directory/grid.csv\", DataFrame)\n\n# Process storage data\ndictStorage = Dict(\n    row.name => (\n        energy_cost = row.energy_cost,\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate,\n        charge_efficiency = row.charge_efficiency,\n        discharge_efficiency = row.discharge_efficiency,\n        self_discharge_rate = row.self_discharge_rate\n    ) for row in eachrow(dfStorage)\n)\n\n# Process wind turbine data\ndictWindTurbines = Dict(\n    row.name => (\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate\n    ) for row in eachrow(dfWindTurbines)\n)\n\n# Process PV data\ndictPV = Dict(\n    row.name => (\n        power_cost = row.power_cost,\n        lifetime = row.lifetime,\n        discount_rate = row.discount_rate\n    ) for row in eachrow(dfPV)\n)\n\n# Process scenario data\ndictScenarios = Dict()\nfor scenario in unique(dfScenarios.scenario)\n    scenario_data = dfScenarios[dfScenarios.scenario .== scenario, :]\n    dictScenarios[scenario] = (\n        datetime = scenario_data.datetime,\n        demand = scenario_data.demand,\n        wind_cf = scenario_data.wind_cf,\n        pv_cf = scenario_data.pv_cf,\n        market_price = scenario_data.market_price,\n        probability = scenario_data.probability[1]\n    )\nend\n\n# Process grid data\ndictGrid = Dict(\n    row.name => (\n        taxes_levies = row.taxes_levies,\n    ) for row in eachrow(dfGrid)\n)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 4. Model Implementation\n\nNow, let's implement the Stochastic System Design model using the dictionary format:\n\n\n\n\n\n\n\n\n::: {#8 .cell execution_count=0}\n``` {.julia .cell-code}\nfunction solve_stochastic_design(dictStorage, dictWindTurbines, dictPV, dictScenarios, dictGrid, max_budget)\n    # Create model\n    model = Model(HiGHS.Optimizer)\n    set_silent(model)\n    \n    # Define sets\n    T = 1:168  # Time periods (hours)\n    S = keys(dictStorage)  # Set of storage systems\n    W = keys(dictWindTurbines)  # Set of wind parks\n    V = keys(dictPV)  # Set of PV parks\n    Ω = keys(dictScenarios)  # Set of scenarios\n    \n    # Calculate PVAF for each component type\n    pvaf = Dict(\n        \"storage\" => (1 + dictStorage[\"storage\"].discount_rate)^dictStorage[\"storage\"].lifetime / \n                    (dictStorage[\"storage\"].discount_rate * (1 + dictStorage[\"storage\"].discount_rate)^dictStorage[\"storage\"].lifetime),\n        \"wind\" => (1 + dictWindTurbines[\"wind\"].discount_rate)^dictWindTurbines[\"wind\"].lifetime / \n                 (dictWindTurbines[\"wind\"].discount_rate * (1 + dictWindTurbines[\"wind\"].discount_rate)^dictWindTurbines[\"wind\"].lifetime),\n        \"pv\" => (1 + dictPV[\"pv\"].discount_rate)^dictPV[\"pv\"].lifetime / \n               (dictPV[\"pv\"].discount_rate * (1 + dictPV[\"pv\"].discount_rate)^dictPV[\"pv\"].lifetime)\n    )\n    \n    # Decision Variables\n    # First stage (investment)\n    @variable(model, e_nom[s in S] >= 0)  # Nominal energy capacity\n    @variable(model, p_ch_nom[s in S] >= 0)  # Nominal charging power\n    @variable(model, p_dis_nom[s in S] >= 0)  # Nominal discharging power\n    @variable(model, p_w_nom[w in W] >= 0)  # Nominal wind power\n    @variable(model, p_v_nom[v in V] >= 0)  # Nominal PV power\n    \n    # Second stage (operation)\n    @variable(model, p_w[w in W, t in T, ω in Ω] >= 0)  # Wind power output\n    @variable(model, p_v[v in V, t in T, ω in Ω] >= 0)  # PV power output\n    @variable(model, p_in[t in T, ω in Ω] >= 0)  # Grid import\n    @variable(model, p_out[t in T, ω in Ω] >= 0)  # Grid export\n    @variable(model, p_ch[s in S, t in T, ω in Ω] >= 0)  # Storage charging\n    @variable(model, p_dis[s in S, t in T, ω in Ω] >= 0)  # Storage discharging\n    @variable(model, e[s in S, t in T, ω in Ω] >= 0)  # Storage energy level\n    \n    # Annual cost variables\n    @variable(model, AC_inv_s[s in S] >= 0)  # Annual storage investment cost\n    @variable(model, AC_inv_w[w in W] >= 0)  # Annual wind investment cost\n    @variable(model, AC_inv_v[v in V] >= 0)  # Annual PV investment cost\n    @variable(model, AC_grid_imp[ω in Ω] >= 0)  # Annual grid import cost\n    @variable(model, AR_grid_exp[ω in Ω] >= 0)  # Annual grid export revenue\n    \n    # Objective Function\n    @objective(model, Min, \n        sum(AC_inv_s[s] for s in S) +\n        sum(AC_inv_w[w] for w in W) +\n        sum(AC_inv_v[v] for v in V) +\n        sum(dictScenarios[ω].probability * (AC_grid_imp[ω] - AR_grid_exp[ω]) for ω in Ω) * 52.1429\n    )\n    \n    # Investment cost constraints\n    @constraint(model, [s in S],\n        AC_inv_s[s] == dictStorage[s].energy_cost/pvaf[\"storage\"] * e_nom[s] +\n                      dictStorage[s].power_cost/pvaf[\"storage\"] * (p_ch_nom[s] + p_dis_nom[s])\n    )\n    \n    @constraint(model, [w in W],\n        AC_inv_w[w] == dictWindTurbines[w].power_cost/pvaf[\"wind\"] * p_w_nom[w]\n    )\n    \n    @constraint(model, [v in V],\n        AC_inv_v[v] == dictPV[v].power_cost/pvaf[\"pv\"] * p_v_nom[v]\n    )\n    \n    # Investment budget constraint\n    @constraint(model,\n        sum(dictStorage[s].energy_cost * e_nom[s] +\n            dictStorage[s].power_cost * (p_ch_nom[s] + p_dis_nom[s]) for s in S) +\n        sum(dictWindTurbines[w].power_cost * p_w_nom[w] for w in W) +\n        sum(dictPV[v].power_cost * p_v_nom[v] for v in V) <= max_budget\n    )\n    \n    # Grid electricity costs\n    @constraint(model, [ω in Ω],\n        AC_grid_imp[ω] == sum(\n            (dictScenarios[ω].market_price[t] + dictGrid[\"grid\"].taxes_levies) * p_in[t,ω]\n            for t in T\n        )\n    )\n    \n    @constraint(model, [ω in Ω],\n        AR_grid_exp[ω] == sum(\n            dictScenarios[ω].market_price[t] * p_out[t,ω]\n            for t in T\n        )\n    )\n    \n    # Power balance\n    @constraint(model, [t in T, ω in Ω],\n        sum(p_w[w,t,ω] for w in W) +\n        sum(p_v[v,t,ω] for v in V) +\n        (p_in[t,ω] - p_out[t,ω]) +\n        sum(p_dis[s,t,ω] - p_ch[s,t,ω] for s in S) ==\n        dictScenarios[ω].demand[t]\n    )\n    \n    # Component limits\n    @constraint(model, [w in W, t in T, ω in Ω],\n        p_w[w,t,ω] <= dictScenarios[ω].wind_cf[t] * p_w_nom[w]\n    )\n    \n    @constraint(model, [v in V, t in T, ω in Ω],\n        p_v[v,t,ω] <= dictScenarios[ω].pv_cf[t] * p_v_nom[v]\n    )\n    \n    @constraint(model, [s in S, t in T, ω in Ω],\n        p_ch[s,t,ω] <= p_ch_nom[s]\n    )\n    \n    @constraint(model, [s in S, t in T, ω in Ω],\n        p_dis[s,t,ω] <= p_dis_nom[s]\n    )\n    \n    @constraint(model, [s in S, t in T, ω in Ω],\n        e[s,t,ω] <= e_nom[s]\n    )\n    \n    # Storage energy balance\n    @constraint(model, [s in S, t in 2:length(T), ω in Ω],\n        e[s,t,ω] == (1 - dictStorage[s].self_discharge_rate) * e[s,t-1,ω] +\n                    dictStorage[s].charge_efficiency * p_ch[s,t,ω] -\n                    p_dis[s,t,ω] / dictStorage[s].discharge_efficiency\n    )\n    \n    @constraint(model, [s in S, ω in Ω],\n        e[s,1,ω] == dictStorage[s].charge_efficiency * p_ch[s,1,ω] -\n                    p_dis[s,1,ω] / dictStorage[s].discharge_efficiency\n    )\n    \n    # Solve the model\n    optimize!(model)\n\n    # Assert that the solution is feasible\n    if termination_status(model) != MOI.OPTIMAL\n        ts = termination_status(model)\n        @info \"Optimization finished. The model was not solved correctly. Termination Status: $ts\"\n        # Helpful resource: https://jump.dev/JuMP.jl/stable/manual/solutions/#Conflicts\n    end\n\n    # Return results\n    return (\n        e_nom = value.(e_nom),\n        p_ch_nom = value.(p_ch_nom),\n        p_dis_nom = value.(p_dis_nom),\n        p_w_nom = value.(p_w_nom),\n        p_v_nom = value.(p_v_nom),\n        total_cost = objective_value(model),\n        investment_costs = Dict(\n            \"storage\" => value.(AC_inv_s[\"storage\"]),\n            \"wind\" => value.(AC_inv_w[\"wind\"]),\n            \"pv\" => value.(AC_inv_v[\"pv\"])\n        ),\n        operational_costs = Dict(\n            \"grid_import\" => sum(dictScenarios[ω].probability * value.(AC_grid_imp[ω]) for ω in Ω) * 52.1429,\n            \"grid_export\" => sum(dictScenarios[ω].probability * value.(AR_grid_exp[ω]) for ω in Ω) * 52.1429\n        ),\n        operational_variables = Dict(\n            \"storage_energy\" => value.(e),\n            \"storage_charge\" => value.(p_ch),\n            \"storage_discharge\" => value.(p_dis),\n            \"wind_power\" => value.(p_w),\n            \"pv_power\" => value.(p_v),\n            \"grid_import\" => value.(p_in),\n            \"grid_export\" => value.(p_out)\n        )\n    )\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 5. Solve and Analyze Results\n\nLet's solve the model with a maximum budget of 50 million EUR:\n\n\n\n\n\n\n\n\n::: {#10 .cell execution_count=0}\n``` {.julia .cell-code}\n# Solve model\nmax_budget = 50_000_000  # 50 million EUR\nresults = solve_stochastic_design(dictStorage, dictWindTurbines, dictPV, dictScenarios, dictGrid, max_budget)\n\n# Create results DataFrame\nresults_df = DataFrame(\n    component = String[],\n    capacity = Float64[],\n    investment_cost = Float64[]\n)\n\n# Add storage results\npush!(results_df, (\"Storage\", results.e_nom[\"storage\"], results.investment_costs[\"storage\"]))\n\n# Add wind results\npush!(results_df, (\"Wind\", results.p_w_nom[\"wind\"], results.investment_costs[\"wind\"]))\n\n# Add PV results\npush!(results_df, (\"PV\", results.p_v_nom[\"pv\"], results.investment_costs[\"pv\"]))\n\n# Calculate total costs\ntotal_investment_cost = sum(values(results.investment_costs))\ntotal_operational_cost = results.operational_costs[\"grid_import\"] - results.operational_costs[\"grid_export\"]\ntotal_cost = total_investment_cost + total_operational_cost\n\n# Print results\nprintln(\"Optimal System Design:\")\nprintln(\"Storage Energy Capacity: $(round(results.e_nom[\"storage\"], digits=2)) MWh\")\nprintln(\"Storage Charging Power: $(round(results.p_ch_nom[\"storage\"], digits=2)) MW\")\nprintln(\"Storage Discharging Power: $(round(results.p_dis_nom[\"storage\"], digits=2)) MW\")\nprintln(\"Wind Power Capacity: $(round(results.p_w_nom[\"wind\"], digits=2)) MW\")\nprintln(\"PV Power Capacity: $(round(results.p_v_nom[\"pv\"], digits=2)) MW\")\nprintln(\"\\nCosts:\")\nprintln(\"Total Annual Cost: $(round(total_cost, digits=2)) EUR/year\")\nprintln(\"Annual Investment Cost: $(round(total_investment_cost, digits=2)) EUR/year\")\nprintln(\"Annual Operational Cost: $(round(total_operational_cost, digits=2)) EUR/year\")\nprintln(\"\\nInvestment Costs by Component:\")\nprintln(\"Storage: $(round(results.investment_costs[\"storage\"], digits=2)) EUR/year\")\nprintln(\"Wind: $(round(results.investment_costs[\"wind\"], digits=2)) EUR/year\")\nprintln(\"PV: $(round(results.investment_costs[\"pv\"], digits=2)) EUR/year\")\nprintln(\"\\nOperational Costs:\")\nprintln(\"Grid Import: $(round(results.operational_costs[\"grid_import\"], digits=2)) EUR/year\")\nprintln(\"Grid Export Revenue: $(round(results.operational_costs[\"grid_export\"], digits=2)) EUR/year\")\n\n# Create operational results DataFrame\noperational_df = DataFrame(\n    scenario = String[],\n    hour = Int[],\n    storage_energy = Float64[],\n    storage_charge = Float64[],\n    storage_discharge = Float64[],\n    wind_power = Float64[],\n    pv_power = Float64[],\n    grid_import = Float64[],\n    grid_export = Float64[],\n    demand = Float64[]\n)\n\n# Add operational data for each scenario\nfor ω in keys(dictScenarios)\n    for t in 1:168\n        push!(operational_df, (\n            ω,\n            t,\n            results.operational_variables[\"storage_energy\"][\"storage\", t, ω],\n            results.operational_variables[\"storage_charge\"][\"storage\", t, ω],\n            results.operational_variables[\"storage_discharge\"][\"storage\", t, ω],\n            results.operational_variables[\"wind_power\"][\"wind\", t, ω],\n            results.operational_variables[\"pv_power\"][\"pv\", t, ω],\n            results.operational_variables[\"grid_import\"][t, ω],\n            results.operational_variables[\"grid_export\"][t, ω],\n            dictScenarios[ω].demand[t]\n        ))\n    end\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 6. Create Figures\n\n\n\n\n\n\n\n\n::: {#12 .cell execution_count=0}\n``` {.julia .cell-code}\n# Create figure for component sizes and costs\nfig1 = Figure(size=(800, 800))\n\n# Component sizes\nax1 = Axis(fig1[1, 1], title=\"Optimal Component Sizes\")\nx_pos = 1:length(results_df.component)\nbarplot!(ax1, x_pos, results_df.capacity)\nax1.xticks = (x_pos, results_df.component)\nax1.xticklabelrotation = π/4\nax1.ylabel = \"Capacity [MWh/MW]\"\n\n# Cost breakdown\nax2 = Axis(fig1[1, 2], title=\"Annual Cost Breakdown\", aspect=1)  # Force square aspect ratio\nhidespines!(ax2)  # Hide the axis spines\nhidedecorations!(ax2)  # Hide all decorations (ticks, labels, etc.)\ncosts = [results.investment_costs[\"storage\"], results.investment_costs[\"wind\"], results.investment_costs[\"pv\"]]\ncolors = [:blue, :green, :orange]\nlabels = [\"Storage\", \"Wind\", \"PV\"]\n\n# Create pie chart\npie!(ax2, costs, color=colors, radius=0.8)\n\n# Create legend below the pie chart\nLegend(fig1[2, 2], [PolyElement(color=c) for c in colors], labels, \"Components\", \n    orientation=:horizontal)\n\n# Display figure\ndisplay(fig1)\n\n# Create operational plots\nfig2 = Figure(size=(1200, 1600))\n\n# Storage operation\nax1 = Axis(fig2[1, 1], title=\"Storage Energy Level\")\nfor ω in keys(dictScenarios)\n    lines!(ax1, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].storage_energy,\n           label=ω)\nend\nax1.xlabel = \"Hour\"\nax1.ylabel = \"Energy [MWh]\"\naxislegend(ax1)\n\n# Storage power\nax2 = Axis(fig2[1, 2], title=\"Storage Power\")\nfor ω in keys(dictScenarios)\n    lines!(ax2, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].storage_charge,\n           label=\"Charge - $ω\")\n    lines!(ax2, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].storage_discharge,\n           label=\"Discharge - $ω\")\nend\nax2.xlabel = \"Hour\"\nax2.ylabel = \"Power [MW]\"\naxislegend(ax2)\n\n# Wind power\nax3 = Axis(fig2[2, 1], title=\"Wind Power Generation\")\nfor ω in keys(dictScenarios)\n    lines!(ax3, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].wind_power,\n           label=ω)\nend\nax3.xlabel = \"Hour\"\nax3.ylabel = \"Power [MW]\"\naxislegend(ax3)\n\n# PV power\nax4 = Axis(fig2[2, 2], title=\"PV Power Generation\")\nfor ω in keys(dictScenarios)\n    lines!(ax4, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].pv_power,\n           label=ω)\nend\nax4.xlabel = \"Hour\"\nax4.ylabel = \"Power [MW]\"\naxislegend(ax4)\n\n# Grid interaction\nax5 = Axis(fig2[3, 1], title=\"Grid Import\")\nfor ω in keys(dictScenarios)\n    lines!(ax5, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].grid_import,\n           label=ω)\nend\nax5.xlabel = \"Hour\"\nax5.ylabel = \"Power [MW]\"\naxislegend(ax5)\n\nax6 = Axis(fig2[3, 2], title=\"Grid Export\")\nfor ω in keys(dictScenarios)\n    lines!(ax6, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].grid_export,\n           label=ω)\nend\nax6.xlabel = \"Hour\"\nax6.ylabel = \"Power [MW]\"\naxislegend(ax6)\n\n# Demand\nax7 = Axis(fig2[4, 1:2], title=\"System Demand\")\nfor ω in keys(dictScenarios)\n    lines!(ax7, operational_df[operational_df.scenario .== ω, :].hour,\n           operational_df[operational_df.scenario .== ω, :].demand,\n           label=ω)\nend\nax7.xlabel = \"Hour\"\nax7.ylabel = \"Power [MW]\"\naxislegend(ax7)\n\n# Display figure\ndisplay(fig2)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 7. Sensitivity Analysis Example\n\nLet's analyze how the optimal solution changes with different maximum budgets:\n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n# Test different budgets\nbudgets = [25_000_000, 50_000_000, 75_000_000, 100_000_000]\nresults_by_budget = Dict()\n\nfor budget in budgets\n    results_by_budget[budget] = solve_stochastic_design(dictStorage, dictWindTurbines, dictPV, dictScenarios, dictGrid, budget)\nend\n\n# Create figure\nfig3 = Figure(size=(1200, 800))\n\n# Sort budgets and get corresponding results\nsorted_budgets = sort(budgets)\nsorted_results = [results_by_budget[b] for b in sorted_budgets]\n\n# Component sizes vs budget\nax1 = Axis(fig3[1, 1], title=\"Component Sizes vs Budget\")\nlines!(ax1, sorted_budgets, [r.e_nom[\"storage\"] for r in sorted_results], label=\"Storage Energy\")\nlines!(ax1, sorted_budgets, [r.p_w_nom[\"wind\"] for r in sorted_results], label=\"Wind\")\nlines!(ax1, sorted_budgets, [r.p_v_nom[\"pv\"] for r in sorted_results], label=\"PV\")\nax1.xlabel = \"Maximum Budget [EUR]\"\nax1.ylabel = \"Capacity [MWh or MW]\"\naxislegend(ax1)\n\n# Costs vs budget\nax2 = Axis(fig3[1, 2], title=\"Costs vs Budget\")\nlines!(ax2, sorted_budgets, [r.total_cost for r in sorted_results], label=\"Total Annual Cost\")\nlines!(ax2, sorted_budgets, [r.investment_costs[\"storage\"] for r in sorted_results], label=\"Storage\")\nlines!(ax2, sorted_budgets, [r.investment_costs[\"wind\"] for r in sorted_results], label=\"Wind\")\nlines!(ax2, sorted_budgets, [r.investment_costs[\"pv\"] for r in sorted_results], label=\"PV\")\n\n# Add initial investment cost line\ninitial_investment = [sum([\n    dictStorage[\"storage\"].energy_cost * r.e_nom[\"storage\"] +\n    dictStorage[\"storage\"].power_cost * (r.p_ch_nom[\"storage\"] + r.p_dis_nom[\"storage\"]) +\n    dictWindTurbines[\"wind\"].power_cost * r.p_w_nom[\"wind\"] +\n    dictPV[\"pv\"].power_cost * r.p_v_nom[\"pv\"]\n]) for r in sorted_results]\nlines!(ax2, sorted_budgets, initial_investment, label=\"Initial Investment\", linestyle=:dash)\n\n# Add budget line for reference\nlines!(ax2, sorted_budgets, sorted_budgets, label=\"Maximum Budget\", linestyle=:dot, color=:black)\n\nax2.xlabel = \"Maximum Budget [EUR]\"\nax2.ylabel = \"Annual Cost [EUR/year]\"\naxislegend(ax2)\n\n# Display figure\ndisplay(fig3)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 8. Sensitivity Analysis of the Electricity Price\n\n**TASK**: Watch for **##YOUR CODE HERE** and implement the missing code.\n\n- Implement a sensitivity analysis of the electricity price.\n- Plot the results in a figure.\n- Interpret the results and make a recommendation in section 9.\n\n\n\n\n\n\n\n\n\n::: {#16 .cell execution_count=0}\n``` {.julia .cell-code}\n# Test different price scaling factors\nprice_scales = 1.0:0.1:2.0  # From 100% to 200% in 10% steps\nresults_by_price = Dict()\n\n# Create a copy of the original scenarios to modify\nmodified_scenarios = deepcopy(dictScenarios)\n\n\nfor scale in price_scales\n    # HINT: Scale the market prices in each scenario. Use the modified_scenarios dictionary.\n    ## YOUR CODE HERE\n\n    # Solve the model with modified prices\n    ## YOUR CODE HERE\nend\n\n# Create figure\nfig4 = Figure(size=(1200, 800))\n\n# Sort price scales and get corresponding results\nsorted_scales = sort(collect(keys(results_by_price)))\nsorted_results = [results_by_price[s] for s in sorted_scales]\n\n# Calculate initial investment costs\ninitial_investment = [sum([\n    dictStorage[\"storage\"].energy_cost * r.e_nom[\"storage\"] +\n    dictStorage[\"storage\"].power_cost * (r.p_ch_nom[\"storage\"] + r.p_dis_nom[\"storage\"]) +\n    dictWindTurbines[\"wind\"].power_cost * r.p_w_nom[\"wind\"] +\n    dictPV[\"pv\"].power_cost * r.p_v_nom[\"pv\"]\n]) for r in sorted_results]\n\n# Component sizes vs price scale\nax1 = Axis(fig4[1, 1], title=\"Component Sizes vs Electricity Price\")\nlines!(ax1, sorted_scales, [r.e_nom[\"storage\"] for r in sorted_results], label=\"Storage Energy\")\nlines!(ax1, sorted_scales, [r.p_w_nom[\"wind\"] for r in sorted_results], label=\"Wind\")\nlines!(ax1, sorted_scales, [r.p_v_nom[\"pv\"] for r in sorted_results], label=\"PV\")\nax1.xlabel = \"Price Scale Factor\"\nax1.ylabel = \"Capacity [MWh or MW]\"\naxislegend(ax1)\n\n# Costs vs price scale\nax2 = Axis(fig4[1, 2], title=\"Costs vs Electricity Price\")\nlines!(ax2, sorted_scales, [r.total_cost for r in sorted_results], label=\"Total Annual Cost\")\nlines!(ax2, sorted_scales, [r.investment_costs[\"storage\"] for r in sorted_results], label=\"Storage\")\nlines!(ax2, sorted_scales, [r.investment_costs[\"wind\"] for r in sorted_results], label=\"Wind\")\nlines!(ax2, sorted_scales, [r.investment_costs[\"pv\"] for r in sorted_results], label=\"PV\")\n\n# Add operational costs\noperational_costs = [r.operational_costs[\"grid_import\"] - r.operational_costs[\"grid_export\"] for r in sorted_results]\nlines!(ax2, sorted_scales, operational_costs, label=\"Operational Cost\", linestyle=:dash)\n\nax2.xlabel = \"Price Scale Factor\"\nax2.ylabel = \"Annual Cost [EUR/year]\"\naxislegend(ax2)\n\n# Display figure\ndisplay(fig4)\n\n# Print key findings\nprintln(\"\\nKey Findings from Price Sensitivity Analysis:\")\nprintln(\"1. Impact on Component Sizes:\")\nprintln(\"   - Storage capacity changes from $(round(sorted_results[1].e_nom[\"storage\"], digits=2)) to $(round(sorted_results[end].e_nom[\"storage\"], digits=2)) MWh\")\nprintln(\"   - Wind capacity changes from $(round(sorted_results[1].p_w_nom[\"wind\"], digits=2)) to $(round(sorted_results[end].p_w_nom[\"wind\"], digits=2)) MW\")\nprintln(\"   - PV capacity changes from $(round(sorted_results[1].p_v_nom[\"pv\"], digits=2)) to $(round(sorted_results[end].p_v_nom[\"pv\"], digits=2)) MW\")\n\nprintln(\"\\n2. Impact on Costs:\")\nprintln(\"   - Total cost changes from $(round(sorted_results[1].total_cost, digits=2)) to $(round(sorted_results[end].total_cost, digits=2)) EUR/year\")\nprintln(\"   - Operational cost changes from $(round(operational_costs[1], digits=2)) to $(round(operational_costs[end], digits=2)) EUR/year\")\nprintln(\"   - Investment cost changes from $(round(sorted_results[1].total_cost - operational_costs[1], digits=2)) to $(round(sorted_results[end].total_cost - operational_costs[end], digits=2)) EUR/year\")\n```\n:::\n\n\n\n\n\n\n\n\n\n\n## 9. Recommendations for Hamburg ChemPark GmbH\n\n**TASK: Place your recommendations here: X, Y, Z, W, A, B, C, D, E, F, G.**\n\nBased on our analysis, we can provide the following recommendations for Hamburg ChemPark GmbH for the expected case of a price scaled by 200%:\n\n1. **Optimal System Configuration**:\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n   - Storage system with [X] MWh energy capacity and [Y] MW power capacity\n   - Wind park with [Z] MW capacity\n   - PV system with [W] MW capacity\n```\n:::\n\n\n\n\n\n\n\n\n\n\n2. **Economic Performance**:\n\n\n\n\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code}\n   - Total annual cost: [A] EUR/year\n   - Investment cost: [B] EUR/year\n   - Operational cost: [C] EUR/year\n```\n:::\n\n\n\n\n\n\n\n\n\n\n3. **Findings**:\n\n\n\n\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code}\n    - Significant storage capacity is added at an electricity price scaled by [D]% of the base case.\n    - The annual investment cost increases from base case to 200% case from [E] EUR/year to [F] EUR/year, because the [G] for storage is much lower than for PV.\n```\n:::\n\n\n\n\n\n\n\n\n\n\n**In a comprehensive sensitivity analysis, the following aspects should be considered:**\n\n   - The solution is most sensitive to [parameter]\n   - Key uncertainties include [uncertainty]\n   - Robustness can be improved by [action]\n\n\n::: {.callout-note}\nThe model provides a foundation for decision-making, but additional factors should be considered:\n\n1. Site-specific constraints\n2. Grid connection capacity\n3. Environmental ambitions\n4. Maintenance requirements and costs\n5. Future expansion possibilities\n:::\n\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-mes_files"
    ],
    "filters": [],
    "includes": {}
  }
}