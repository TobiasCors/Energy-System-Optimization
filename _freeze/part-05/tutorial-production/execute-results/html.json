{
  "hash": "d252c8faf76856040980786be045f03a",
  "result": {
    "engine": "julia",
    "markdown": "---\ntitle: \"Tutorial V - Production Planning in Breweries\"\nsubtitle: \"Applied Optimization with Julia\"\n\nformat:\n    html:\n        theme: litera\n        highlight-style: arrow\n        linkcolor: \"#a60000\"\n        code-copy: true\n        code-link: true\n        toc: true\n        toc-location: right\n        code-overflow: wrap\n    pdf: \n        documentclass: report\n        geometry:\n            - margin=1in\n        fontfamily: roboto\n        fontfamilyoptions: sfdefault\n        colorlinks: true\n    ipynb:\n        code-copy: true\n        code-overflow: wrap\n\nengine: julia\n---\n\n\n\n\n\n\n\n\n# 1. Modelling the CLSP\n\nImplement the CLSP from the lecture in Julia. Before we start, let's load the necessary packages and data.\n\n\n\n\n\n\n\n\n\n\n\n::: {#4 .cell execution_count=1}\n``` {.julia .cell-code}\nusing JuMP, HiGHS\nusing CSV\nusing DelimitedFiles\nusing DataFrames\nusing Plots\nusing StatsPlots\nimport Pkg; Pkg.add(\"PlotlyBase\")\nplotly() # This will create interactive plots later on\n```\n:::\n\n\n\n\n\n\n\n\n\n\n::: {.callout-tip}\nIf you haven't installed the packages yet, you can do so by running `using Pkg` first and then `Pkg.add(\"JuMP\")`, `Pkg.add(\"HiGHS\")`, `Pkg.add(\"DataFrames\")`, `Pkg.add(\"Plots\")`, and `Pkg.add(\"StatsPlots\")`.\n:::\n\nNow, let's load the data. The weekly demand in bottles $d_{i,t}$, the available time at the bottling plant in hours $a_t$, the time required to bottle each beer in hours $b_i$, and the setup time in hours $g_i$ are provided as CSV files.\n\n\n\n\n\n\n\n\n::: {#6 .cell execution_count=1}\n``` {.julia .cell-code}\n# Get the directory of the current file\nfile_directory = \"$(@__DIR__)/data\"\n\n# Load the data about the available time at the bottling plant\navailableTime = CSV.read(\"$file_directory/availabletime.csv\", DataFrame)\nprintln(\"Number of periods: $(nrow(availableTime))\")\nprintln(\"First 5 rows of available time per period:\")\nprintln(availableTime[1:5, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of periods: 27\nFirst 5 rows of available time per period:\n5×2 DataFrame\n Row │ period   available_capacity \n     │ String7  Int64              \n─────┼─────────────────────────────\n   1 │ week_01                 168\n   2 │ week_02                 168\n   3 │ week_03                 168\n   4 │ week_04                 168\n   5 │ week_05                  48\n```\n:::\n:::\n\n\n\n::: {#8 .cell execution_count=1}\n``` {.julia .cell-code}\n# Load the data about the bottling time for each beer\nbottlingTime = CSV.read(\"$file_directory/bottlingtime.csv\", DataFrame)\nprintln(\"Number of beers: $(nrow(bottlingTime))\")\nprintln(\"Bottling time per beer:\")\nprintln(bottlingTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNumber of beers: 6\nBottling time per beer:\n6×2 DataFrame\n Row │ beer_type   bottling_time \n     │ String15    Float64       \n─────┼───────────────────────────\n   1 │ Pilsener          0.00222\n   2 │ Blonde_Ale        0.00111\n   3 │ Amber_Ale         0.00139\n   4 │ Brown_Ale         0.00222\n   5 │ Porter            0.00167\n   6 │ Stout             0.00111\n```\n:::\n:::\n\n\n\n::: {#10 .cell execution_count=1}\n``` {.julia .cell-code}\n# Load the data about the setup time for each beer\nsetupTime = CSV.read(\"$file_directory/setuptime.csv\", DataFrame)\nprintln(\"Setup time per beer:\")\nprintln(setupTime)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nSetup time per beer:\n6×2 DataFrame\n Row │ beer_type   setup_time \n     │ String15    Int64      \n─────┼────────────────────────\n   1 │ Pilsener            10\n   2 │ Blonde_Ale          11\n   3 │ Amber_Ale            8\n   4 │ Brown_Ale            8\n   5 │ Porter              11\n   6 │ Stout                9\n```\n:::\n:::\n\n\n\n::: {#12 .cell execution_count=1}\n``` {.julia .cell-code}\n# Load the data about the weekly demand for each beer\ndemandCustomers = CSV.read(\"$file_directory/demand.csv\", DataFrame)\nprintln(\"First 5 rows of demand per beer:\")\nprintln(demandCustomers[1:5, :])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFirst 5 rows of demand per beer:\n5×3 DataFrame\n Row │ beer_type   period   demand \n     │ String15    String7  Int64  \n─────┼─────────────────────────────\n   1 │ Pilsener    week_01    3853\n   2 │ Blonde_Ale  week_01    8372\n   3 │ Amber_Ale   week_01   16822\n   4 │ Brown_Ale   week_01   13880\n   5 │ Porter      week_01   10642\n```\n:::\n:::\n\n\n\n\n\n\n\n\n\n\nConsider in your implementation, that **each hour of setup** is associated with a cost of 1000 Euros, and the inventory holding cost for unsold bottles at the end of each period is 0.1 Euro per bottle. Implement **both parameters** for the cost of setup and the inventory holding cost in the model. Call them `setupHourCosts` and `warehouseCosts`.\n\n\n\n\n\n\n\n\n::: {#14 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\nNext, you need to prepare the given data for the model. Create a dictionary for the available time, bottling time, and setup time. Call them `dictAvailableTime`, `dictBottlingTime`, and `dictSetupTime`.\n\n\n\n\n\n\n\n\n::: {#18 .cell execution_count=0}\n``` {.julia .cell-code}\n# Prepare the data for the model\ndictDemand = Dict((row.beer_type,row.period) => row.demand for row in eachrow(demandCustomers))\n\n# YOUR CODE BELOW\n\n\n```\n:::\n\n\n\n::: {#20 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Validate your solution\n@assert length(dictAvailableTime) == nrow(availableTime) \"Available time dictionary should have same length as input data\"\n@assert length(dictBottlingTime) == nrow(bottlingTime) \"Bottling time dictionary should have same length as input data\"\n@assert length(dictSetupTime) == nrow(setupTime) \"Setup time dictionary should have same length as input data\"\n\n# Check that all values are positive\n@assert all(v -> v > 0, values(dictAvailableTime)) \"All available time values must be positive\"\n@assert all(v -> v > 0, values(dictBottlingTime)) \"All bottling time values must be positive\"\n@assert all(v -> v > 0, values(dictSetupTime)) \"All setup time values must be positive\"\n\n# Check that dictionaries contain all expected keys\n@assert all(p -> haskey(dictAvailableTime, p), availableTime.period) \"Missing periods in available time dictionary\"\n@assert all(b -> haskey(dictBottlingTime, b), bottlingTime.beer_type) \"Missing beer types in bottling time dictionary\"\n@assert all(b -> haskey(dictSetupTime, b), setupTime.beer_type) \"Missing beer types in setup time dictionary\"\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNext, we define the model instance for the CLSP.\n\n\n\n\n\n\n\n\n::: {#22 .cell execution_count=0}\n``` {.julia .cell-code}\n# Prepare the model instance\nlotsizeModel = Model(HiGHS.Optimizer)\nset_attribute(lotsizeModel, \"presolve\", \"on\")\nset_time_limit_sec(lotsizeModel, 60.0)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNow, create your variables. Please name them `productBottled` for the binary variable, `productQuantity` for the production quantity and `WarehouseStockPeriodEnd` for the warehouse stock at the end of each period. We will use these names later in the code to plot the results.\n\n\n\n\n\n\n\n\n::: {#24 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n\n```\n:::\n\n\n\n::: {#26 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Validate your solution\n# Check if variables exist in the model\n@assert haskey(lotsizeModel.obj_dict, :productBottled) \"productBottled variable not found in model\"\n@assert haskey(lotsizeModel.obj_dict, :productQuantity) \"productQuantity variable not found in model\"\n@assert haskey(lotsizeModel.obj_dict, :WarehouseStockPeriodEnd) \"WarehouseStockPeriodEnd variable not found in model\"\n\n# Check variable dimensions\n@assert length(productBottled) == length(dictBottlingTime) * length(dictAvailableTime) \"Incorrect dimensions for productBottled\"\n@assert length(productQuantity) == length(dictBottlingTime) * length(dictAvailableTime) \"Incorrect dimensions for productQuantity\"\n@assert length(WarehouseStockPeriodEnd) == length(dictBottlingTime) * length(dictAvailableTime) \"Incorrect dimensions for WarehouseStockPeriodEnd\"\n\n# Check variable types\n@assert all(is_binary, productBottled) \"productBottled must be binary variables\"\n@assert all(is_integer, productQuantity) == false \"productQuantity must be continuous variables\"\n@assert all(is_integer, WarehouseStockPeriodEnd) == false \"WarehouseStockPeriodEnd must be continuous variables\"\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNext, define the objective function.\n\n\n\n\n\n\n\n\n::: {#28 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#30 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Validate your solution\n# Check if the model has an objective\n@assert objective_function(lotsizeModel) !== nothing \"Model must have an objective function\"\n\n# Check if it's a minimization problem\n@assert objective_sense(lotsizeModel) == MOI.MIN_SENSE \"Objective should be minimization\"\n\n# Check if the objective function contains both cost components\nobj_expr = objective_function(lotsizeModel)\n@assert contains(string(obj_expr), \"productBottled\") \"Objective must include setup costs (productBottled)\"\n@assert contains(string(obj_expr), \"WarehouseStockPeriodEnd\") \"Objective must include warehouse costs (WarehouseStockPeriodEnd)\"\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\nNow, we need to define all necessary constraints for the model. Start with the demand/inventory balance constraint.\n\n::: {.callout-tip}\nThe first period is special, as it does not have a previous period. Furthermore, we are working with strings as variable references, thus we cannot use `t-1` directly as in the lecture. To address this, we could collect and sort all keys and then use their indices to address the previous period. For example, `all_periods[t-1]` would then be the previous period, if we index t just as a range from `2:length(all_periods)`.\n:::\n\n\n\n\n\n\n\n\n::: {#32 .cell execution_count=0}\n``` {.julia .cell-code}\n# Get the first period and all periods\nfirst_period = first(sort(collect(keys(dictAvailableTime))))\nall_periods = sort(collect(keys(dictAvailableTime)))\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\nWith these, we can now define the demand/inventory balance constraint. As this is the first constraint and might be a bit tricky, the solution is already given below.\n\n\n\n\n\n\n\n\n::: {#34 .cell execution_count=0}\n``` {.julia .cell-code}\n# Inventory balance constraints for periods after first period\n@constraint(lotsizeModel, \n    demandBalance[i=keys(dictBottlingTime), t=2:length(all_periods)],\n    WarehouseStockPeriodEnd[i,all_periods[t-1]] + productQuantity[i,all_periods[t]] - WarehouseStockPeriodEnd[i,all_periods[t]] == dictDemand[i,all_periods[t]]\n    )\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNext, we need to ensure that we setup the production for a beer type only if we bottle the type at least once.\n\n\n\n\n\n\n\n\n::: {#36 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\nLast, we need to define the constraint that limits the production quantity to the number of bottles that can be bottled within the available time.\n\n\n\n\n\n\n\n\n::: {#38 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\nFinally, implement the solve statement for your model instance.\n\n\n\n\n\n\n\n\n::: {#40 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#42 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Validate your solution\n@assert 600000 <= objective_value(lotsizeModel) <= 700000 \"Objective value should be between 600,000 and 700,000\"\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNow, unfortunately we cannot assert the value of the objective function perfectly here as we have to abort the computation due to the time limit and everybody is likely getting different results. The solution for the first task will likely be in the [range of 600,000 to 700,000]{.highlight}. If your model is solved within seconds, your formulation is not correct.\n\nThe following code creates production and warehouse plots for you. Use it to verify and visualize your solution in the following tasks.\n\n::: {.callout-note}\nThe creation of the dataframes and the plots is implemented inside of a function, as we will need to use it multiple times in the following tasks.\n:::\n\n\n\n\n\n\n\n\n::: {#44 .cell execution_count=0}\n``` {.julia .cell-code}\n# Create the production results\nfunction create_production_results()\n    # Create a DataFrame to store the results\n    productionResults = DataFrame(\n        period = String[],\n        product = String[],\n        productBottled = Bool[],\n        productQuantity=Int[],\n        WarehouseStockPeriodEnd=Int[]\n    )\n\n    # Populate the DataFrame with the results\n    for i in keys(dictSetupTime)\n        for t in keys(dictAvailableTime)\n            push!(\n                productionResults,(\n                period = t,\n                product = i,\n                productBottled = value(productBottled[i,t])>0.5 ? true : false,\n                productQuantity = ceil(Int,value(productQuantity[i,t])),\n                WarehouseStockPeriodEnd = ceil(Int,value(WarehouseStockPeriodEnd[i,t])),\n                )\n            )\n        end\n    end\n\n    sort!(productionResults,[:period, :product])\n    return productionResults\nend\n\n# Create the production plot\nfunction create_production_plot(productionResults)\n    p = groupedbar(\n        productionResults.period, \n        productionResults.productQuantity, \n        group=productionResults.product, \n        ylabel=\"Production Quantity (Bottles)\",\n        xlabel=\"Period\",\n        title=\"Production Schedule by Beer Type\",\n        size=(1200,600),\n        palette = :Set3,\n        legend=:outertopright,\n        xrotation = 45,   \n        legendtitle=\"Beer Type\",\n        bar_width=0.7,    \n        grid=false,       \n        dpi=300           \n    )\n    return p\nend\n\n# Create the warehouse stock plot\nfunction create_warehouse_plot(productionResults)\n    p = groupedbar(\n        productionResults.period, \n        productionResults.WarehouseStockPeriodEnd, \n        group=productionResults.product,\n        ylabel=\"Warehouse Stock\", \n        xlabel=\"Period\",\n        title=\"Warehouse Stock\",\n        size=(1200,600),\n        palette = :Set3,  \n        legend=:outertopright,\n        xrotation = 45,   \n        legendtitle=\"Beer Type\",\n        bar_width=0.7,    \n        grid=false,       \n        dpi=300           \n    )\n    return p\nend\n\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThe following code creates the production plot.\n\n\n\n\n\n\n\n\n::: {#46 .cell execution_count=0}\n``` {.julia .cell-code}\nproductionResults = create_production_results()\np = create_production_plot(productionResults)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThe following code creates the warehouse stock plot.\n\n\n\n\n\n\n\n\n::: {#48 .cell execution_count=0}\n``` {.julia .cell-code}\nproductionResults = create_production_results()\np = create_warehouse_plot(productionResults)\n```\n:::\n\n\n\n\n\n\n\n\n\n\nNext, we calculate the setup and inventory costs for each period and store them in a DataFrame. This should also work for you, if you followed the previous name instructions.\n\n\n\n\n\n\n\n\n::: {#50 .cell execution_count=0}\n``` {.julia .cell-code}\n# Calculate costs per period\nfunction create_cost_results()\n    costResults = DataFrame(\n        period = String[],\n        setup_costs = Float64[],\n        inventory_costs = Float64[]\n    )\n\n    for t in sort(collect(keys(dictAvailableTime)))\n        # Calculate setup costs for this period\n        period_setup_costs = sum(\n            setupHourCosts * dictSetupTime[i] * value(productBottled[i,t]) \n            for i in keys(dictBottlingTime)\n        )\n        \n        # Calculate inventory costs for this period\n        period_inventory_costs = sum(\n            warehouseCosts * value(WarehouseStockPeriodEnd[i,t]) \n            for i in keys(dictBottlingTime)\n        )\n        \n        push!(costResults, (\n            period = t,\n            setup_costs = period_setup_costs,\n            inventory_costs = period_inventory_costs\n        ))\n    end\n\n    # Stack the cost columns\n    stacked_costs = stack(costResults, [:setup_costs, :inventory_costs], \n                         variable_name=\"Cost_Type\", value_name=\"Cost\")\n    return stacked_costs\nend\n\n# Create the cost plot\nfunction create_cost_plot(stacked_costs)\n    p = groupedbar(\n        stacked_costs.period,\n        stacked_costs.Cost,\n        group=stacked_costs.Cost_Type,\n        ylabel=\"Costs (€)\",\n        xlabel=\"Period\",\n        title=\"Setup and Inventory Costs per Period\",\n        size=(1200,600),\n        palette=:Set2,\n        legend=:outertopright,\n        xrotation=45,\n        legendtitle=\"Cost Type\",\n        bar_width=0.7,\n        grid=false,\n        dpi=300\n    )\n    return p\nend\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThe following code calls the setup and inventory costs plot.\n\n\n\n\n\n\n\n::: {#52 .cell execution_count=0}\n``` {.julia .cell-code}\nstacked_costs = create_cost_results()\np = create_cost_plot(stacked_costs)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# 2. Initial Warehouse Stock\n\nThe model currently sets the initial warehouse stock levels without any restrictions. Modify your model to incorporate an initial stock for **all types of beer of zero** at the beginning of the **initial planning period**. \n\nTo solve this task, you can simply extend the previous model by these additional constraints in the cell below. Afterwards, you can re-run the optimization.\n\n\n\n\n\n\n\n\n::: {#54 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n::: {#56 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Validate your solution\n@assert 700000 <= objective_value(lotsizeModel) <= 760000 \"Objective value should be between 700,000 and 760,000\"\n```\n:::\n\n\n\n\n\n\n\n\n\n\nThe objective value should now be higher, as the solution space is smaller than before and the initial stock is zero for all beer types. You can check the plots for the production and warehouse stock to verify this.\n\n\n\n\n\n\n\n\n::: {#58 .cell execution_count=0}\n``` {.julia .cell-code}\nproductionResults = create_production_results()\np = create_production_plot(productionResults)\n```\n:::\n\n\n\n::: {#60 .cell execution_count=0}\n``` {.julia .cell-code}\nproductionResults = create_production_results()\np = create_warehouse_plot(productionResults)\n```\n:::\n\n\n\n::: {#62 .cell execution_count=0}\n``` {.julia .cell-code}\nstacked_costs = create_cost_results()\np = create_cost_plot(stacked_costs)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# 3. Scheduled Repair\n\nUnfortunately, the bottling plant has to undergo maintenance in periods `\"week_10\"` and `\"week_11\"`. **Extend your model** to prevent any production in those two periods. \n\nAgain, to solve this task, you can simply extend the previous model by these additional constraints in the cell below. Afterwards, you can re-run the optimization.  \n\n\n\n\n\n\n\n\n::: {#64 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n\n```\n:::\n\n\n\n::: {#66 .cell execution_count=0}\n``` {.julia .cell-code code-fold=\"true\"}\n# Validate your solution\n@assert 760000 <= objective_value(lotsizeModel) <= 800000 \"Objective value should be between 760,000 and 800,000\"\n```\n:::\n\n\n\n\n\n\n\n\n\n\nAgain, the objective value should be higher, because the solution space is smaller. You can check the plots for the production and warehouse stock to verify whether the production is zero in the maintenance periods.\n\n\n\n\n\n\n\n\n::: {#68 .cell execution_count=0}\n``` {.julia .cell-code}\nproductionResults = create_production_results()\np = create_production_plot(productionResults)\n```\n:::\n\n\n\n::: {#70 .cell execution_count=0}\n``` {.julia .cell-code}\nproductionResults = create_production_results()\np = create_warehouse_plot(productionResults)\n```\n:::\n\n\n\n::: {#72 .cell execution_count=0}\n``` {.julia .cell-code}\nstacked_costs = create_cost_results()\np = create_cost_plot(stacked_costs)\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# 4. Production Schedule Analysis\n\nAnalyze the production schedule outlined in section 2 of this tutorial. Is the workload **distributed evenly** across all time periods? Provide a rationale for your assessment. \n\nPlease answer in the following cell. Note, that `#=` and `=#` are a comment delimiter for multiline comments. You can write whatever you want between them and the code will not be executed.\n\n\n\n\n\n\n\n\n::: {#74 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR REASONING BELOW\n#=\n\n\n\n=#\n```\n:::\n\n\n\n\n\n\n\n\n\n\nBased on the production data from the final period, **calculate the ending inventory levels for each type of beer**. Discuss any significant findings. Compute the ending inventory levels for each type of beer in the following cell. You can name the DataFrame however you want.\n\n\n\n\n\n\n\n\n::: {#76 .cell execution_count=0}\n``` {.julia .cell-code}\n# YOUR CODE BELOW\n\n```\n:::\n\n\n\n\n\n\n\n\n\n\n# 5. Biannual Bottling Strategy\n\nReflecting on a scenario where the company schedules its bottling operations **biannually** using the current method: identify and discuss potential pitfalls of this strategy. \n\nOffer at least one actionable suggestion for enhancing the efficiency or effectiveness of the production planning process.\n\nYour answer goes here.\n\n\n\n\n\n\n\n\n::: {#78 .cell execution_count=1}\n``` {.julia .cell-code}\n# YOUR ANSWER BELOW\n#=\n\n\n\n=#\n```\n:::\n\n\n\n\n\n\n\n\n\n\n---\n\n\n# Solutions\n\nYou will likely find solutions to most exercises online. However, I strongly encourage you to work on these exercises independently without searching explicitly for the exact answers to the exercises. Understanding someone else's solution is very different from developing your own. Use the lecture notes and try to solve the exercises on your own. This approach will significantly enhance your learning and problem-solving skills.\n\nRemember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities. If you encounter difficulties, review the lecture materials, experiment with different approaches, and don't hesitate to ask for clarification during class discussions.\n\nLater, you will find the solutions to these exercises online in the associated GitHub repository, but we will also quickly go over them in next week's tutorial. To access the solutions, click on the Github button on the lower right and search for the folder with today's lecture and tutorial. Alternatively, you can ask ChatGPT or Claude to explain them to you. But please remember, the goal is not just to complete the exercises, but to understand the concepts and improve your programming abilities.\n\n",
    "supporting": [
      "tutorial-production_files"
    ],
    "filters": [],
    "includes": {}
  }
}